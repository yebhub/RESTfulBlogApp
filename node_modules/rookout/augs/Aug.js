"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _RookError = _interopRequireDefault(require("../processor/RookError"));

var _exceptions = require("../exceptions");

var _logger = require("../logger");

var _UserWarnings = _interopRequireDefault(require("../UserWarnings"));

var _ContainerNamespace = _interopRequireDefault(require("../processor/namespaces/ContainerNamespace"));

var _JSUtilsNamespace = require("../processor/namespaces/JSUtilsNamespace");

var _NoopNamespace = require("../processor/namespaces/NoopNamespace");

var _ProcessStateNamespace = require("../processor/namespaces/ProcessStateNamespace");

var _RateLimiter = _interopRequireDefault(require("./RateLimiter"));

var _DebuggerBackchannel = _interopRequireDefault(require("../services/DebuggerBackchannel"));

var _JSObjectNamespace = _interopRequireDefault(require("../processor/namespaces/JSObjectNamespace"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const utils = require("../utils");

const uuid4 = require("uuid/v4");

process.__rookout_backchannel = new _DebuggerBackchannel.default();
process.__rookout_backchannel.ContainerNamespace = _ContainerNamespace.default;
process.__rookout_backchannel.ObjectNamespace = _JSObjectNamespace.default;

class Aug {
  constructor(augId, location, action, condition, output, triggerServices, maxAugTime, limits) {
    this.triggerServices = triggerServices;
    this.augId = augId;
    this.location = location;
    this.action = action;
    this.output = output;
    this.status = null;
    this.maxAugTime = maxAugTime;
    this.enabled = true;
    this.condition = condition;
    this._hasBeenRateLimited = false;
    this._warningCache = new Map();
    this._logCache = new Map();

    if (limits !== undefined && limits.length > 0) {
      this.rateLimiter = new _RateLimiter.default(limits[0], limits[1]);
    } else {
      this.rateLimiter = new _RateLimiter.default();
    }

    this.executed = false;
  }

  addAug() {
    try {
      this.location.addAug(this.triggerServices, this);
    } catch (e) {
      const message = "Exception when adding aug";

      _logger.logger.exception(message, e);

      this.setError(new _RookError.default(e, message));
    }
  }

  removeAugTemporarilyAndReapplyAfterDuration(duration) {
    _logger.logger.info("Temporarily removing aug %s for %sms", this.augId, duration);

    this.triggerServices.removeAugTemporarily(this.augId, duration);
  }

  execute(stack, extracted) {
    if (!this.enabled) {
      return;
    }

    try {
      const startTime = utils.getTimeInNanoseconds();

      if (!this.checkRateLimit(startTime)) {
        let duration = utils.getTimeInNanoseconds() - startTime;
        this.rateLimiter.record(startTime, duration);
        return;
      }

      let namespace = new _ContainerNamespace.default({
        'frame': stack ? stack.readKey(0) : _NoopNamespace.NoopNamespaceInstance,
        'stack': stack || _NoopNamespace.NoopNamespaceInstance,
        'utils': _JSUtilsNamespace.JSUtilsNamespaceInstance,
        'trace': _NoopNamespace.NoopNamespaceInstance,
        'state': _ProcessStateNamespace.ProcessStateNamespaceInstance,
        "extracted": extracted
      });

      if (this.condition !== undefined) {
        if (!this.condition.evaluate(namespace)) {
          const duration = utils.getTimeInNanoseconds() - startTime;
          this.rateLimiter.record(startTime, duration);
          return;
        }
      }

      const msgId = uuid4().replace(/\-/g, "");

      if (this.executed) {
        _logger.logger.debug("Executing aug-\t%s (msg ID %s)", this.augId, msgId);
      } else {
        _logger.logger.info("Executing aug for the first time - %s", this.augId);

        this.executed = true;
      }

      namespace.writeAttribute('store', new _ContainerNamespace.default({}));
      this.action.execute(this.augId, msgId, namespace, this.output, new _UserWarnings.default(this));
      let duration = utils.getTimeInNanoseconds() - startTime;
      this.rateLimiter.record(startTime, duration);

      if (this.maxAugTime && this.maxAugTime > 0 && duration > this.maxAugTime) {
        this.enabled = false;
        throw new _exceptions.RookRuleMaxExecutionTimeReached();
      }
    } catch (e) {
      const message = "Exception while processing Aug";
      let rookError = new _RookError.default(e, message);

      if (!this.shouldSilenceLog(rookError, this._logCache)) {
        _logger.logger.exception(message, e);
      }

      this.setError(rookError);
    }
  }

  setActive() {
    this.sendRuleStatus("Active");
  }

  setPending() {
    this.sendRuleStatus("Pending");
  }

  setRemoved() {
    this.sendRuleStatus("Deleted");
  }

  setError(error) {
    this.sendRuleStatus("Error", error);
  }

  setUnknown(error) {
    this.sendRuleStatus("Unknown", error);
  }

  sendWarning(error) {
    if (this.shouldSilenceLog(error, this._warningCache)) {
      return;
    }

    _logger.logger.warn(error.message);

    this.output.sendWarning(this.augId, error);
  }

  sendRuleStatus(status, error = null) {
    if (this.status === status) {
      return;
    }

    _logger.logger.info("Updating rule status for %s to %s", this.augId, status);

    this.status = status;
    this.output.sendRuleStatus(this.augId, status, error);
  }

  shouldSilenceLog(error, logCache) {
    if (logCache.has(error.message) || logCache.size >= 10) {
      return true;
    }

    logCache.set(error.message, true);
    return false;
  }

  checkRateLimit(startTime) {
    try {
      if (!this.rateLimiter.allow(startTime) || this.output.areUserMessagesFull()) {
        if (!this._hasBeenRateLimited) {
          this.sendWarning(new _RookError.default(new _exceptions.RookRuleRateLimited()));
          this._hasBeenRateLimited = true;
        } // removeAugTemporarilyAndReapplyAfterDuration expects to get a duration of timeout in milliseconds
        // and window_size is currently in nanoseconds


        let window_size_ms = utils.NanosecToMillisec(this.rateLimiter.window_size);
        this.removeAugTemporarilyAndReapplyAfterDuration(window_size_ms / 2);
        return false;
      } else {
        return true;
      }
    } catch (e) {
      return false;
    }
  }

}

exports.default = Aug;
//# sourceMappingURL=Aug.js.map
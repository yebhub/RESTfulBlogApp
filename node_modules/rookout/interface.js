'use strict';

var _utils = require("./utils");

var _exceptions = require("./exceptions");

const util = require('util');

const {
  RookMissingToken,
  RookUnsupportedNodeVersion,
  RookInvalidToken,
  RookInvalidOptions,
  RookOldServers,
  RookUnsupportedRuntime
} = require('./exceptions');

const trueValues = ['y', 'Y', 'yes', 'Yes', 'YES', 'true', 'True', 'TRUE', '1', true];

class Rook {
  constructor() {
    this.savedOptions = null;
  }

  start(options = {}) {
    if (Object.keys(options).length === 0 && this.savedOptions !== null) {
      options = this.savedOptions;
    }

    let self = this;
    this.startAttempted = true;
    return new Promise((resolve, reject) => {
      try {
        if (self.singleton) resolve();
        self.debug = false;

        if (options.debug === undefined) {
          self.debug = trueValues.indexOf(process.env.ROOKOUT_DEBUG) !== -1;
        } else {
          self.debug = options.debug;
        }

        if (options.log_to_stderr === undefined && process.env.ROOKOUT_LOG_TO_STDERR !== undefined) {
          options.log_to_stderr = trueValues.indexOf(process.env.ROOKOUT_LOG_TO_STDERR) !== -1;
        }

        if (options.log_file === undefined && process.env.ROOKOUT_LOG_FILE !== undefined) {
          options.log_file = process.env.ROOKOUT_LOG_FILE;
        }

        if (process.env.LAMBDA_TASK_ROOT) {
          options.log_file = "";

          if (options.lambda_safe_start !== true) {
            throw new _exceptions.RookIllegalLambdaStart();
          }
        }

        options.log_level = options.log_level || process.env.ROOKOUT_LOG_LEVEL;
        self.throw_errors = false;

        if (options.throw_errors !== undefined) {
          self.throw_errors = options.throw_errors;
        }

        if (!(options.skip_node_whitelist || process.env.ROOKOUT_SKIP_NODE_WHITELIST)) {
          Rook.checkVersionSupported();
        }

        const config = require('./config');

        Rook._verifyBoolean(self.throw_errors, 'Rook throw errors should be a boolean');

        if (options.log_to_stderr !== undefined) {
          Rook._verifyBoolean(options.log_to_stderr, 'Rook log to stderr should be a boolean');

          config.LoggingConfiguration.LOG_TO_STDERR = options.log_to_stderr;
        }

        if (options.log_level !== undefined) {
          Rook._verifyString(options.log_level, 'Rook log level should be a String');

          config.LoggingConfiguration.LOG_LEVEL = options.log_level;
        }

        if (options.log_file !== undefined) {
          Rook._verifyString(options.log_file, 'Rook log file should be a String');

          config.LoggingConfiguration.FILE_NAME = options.log_file;
        }

        if (options.tags === undefined) {
          let rawTags = process.env.ROOKOUT_ROOK_TAGS;

          if (rawTags !== undefined) {
            options.tags = [];

            for (let tag of rawTags.replace(/['"]/g, '').split(';')) {
              options.tags.push(_utils.StringUtils.trim(tag));
            }
          }
        } else {
          if (Array.isArray(options.tags)) {
            for (let tag of options.tags) {
              Rook._verifyString(tag, 'Rook tags should be array of strings');
            }
          } else {
            throw new RookInvalidOptions('Rook tags should be array of strings');
          }
        }

        if (options.labels === undefined) {
          let labels = process.env.ROOKOUT_LABELS;

          if (labels !== undefined) {
            options.labels = {};

            for (let label of labels.replace(/['"]/g, '').split(',')) {
              let kv = label.split(':');

              if (kv.length === 2) {
                let key = kv[0];
                let value = kv[1];

                if (key && value) {
                  options.labels[key] = value;
                }
              }
            }
          }
        } else {
          // Normalize the map to native dictionary
          if (options.labels instanceof Map) {
            let originalLabels = options.labels;
            options.labels = {};

            for (let [key, value] of originalLabels) {
              options.labels[key] = value;
            }
          }

          for (let label of Object.keys(options.labels)) {
            // Set the label as an empty string if NULL
            if (options.labels[label] === undefined || options.labels[label] === null) {
              options.labels[label] = "";
            }

            Rook._verifyString(label);

            Rook._verifyString(options.labels[label], 'Rook label should be a map of strings');

            Rook._verifyLabel(label);
          }
        }

        Rook._verifyBoolean(self.debug, 'Rook debug flag should be a boolean');

        if (self.debug) {
          config.LoggingConfiguration.LOG_LEVEL = 'DEBUG';
          config.LoggingConfiguration.LOG_TO_STDERR = true;
          config.LoggingConfiguration.DEBUG = true;
        }

        if (options.git_commit !== undefined) {
          Rook._verifyString(options.git_commit, 'Git commit should be a String');

          config.GitConfiguration.GIT_COMMIT = options.git_commit;
        }

        if (options.git_origin !== undefined) {
          Rook._verifyString(options.git_origin, 'Git origin should be a String');

          config.GitConfiguration.GIT_ORIGIN = options.git_origin;
        }

        options.sources = Rook.parseSourcesList(options.sources);

        if (options.sources !== undefined) {
          config.GitConfiguration.SOURCES = options.sources;
        }

        let maxScriptsFailSafe = options.maxScriptsFailSafe || process.env.ROOKOUT_MAX_SCRIPTS_COUNT_FAIL_SAFE || config.InstrumentationConfig.MAX_SCRIPTS_COUNT_FAIL_SAFE;
        config.InstrumentationConfig.MAX_SCRIPTS_COUNT_FAIL_SAFE = maxScriptsFailSafe;
        let maxScriptsSizeFailSafe = options.maxScriptsSizeFailSafe || process.env.ROOKOUT_MAX_SCRIPTS_SIZE_FAIL_SAFE || config.InstrumentationConfig.MAX_SCRIPTS_SIZE_FAIL_SAFE;
        config.InstrumentationConfig.MAX_SCRIPTS_SIZE_FAIL_SAFE = maxScriptsSizeFailSafe;
        let enableMonitor = options.enable_monitor || process.env.ROOKOUT_ENABLE_MONITOR || config.MonitorConfiguration.ENABLED;
        config.MonitorConfiguration.ENABLED = enableMonitor;
        let enableMemoryUsageLog = options.enable_memory_usage_log || process.env.ROOKOUT_ENABLE_MEMORY_USAGE_LOG || config.MemoryUsageLogService.ENABLED;
        config.MemoryUsageLogService.ENABLED = enableMemoryUsageLog;
        let memoryUsageLogFile = options.memory_usage_log_file || process.env.ROOKOUT_MEMORY_USAGE_LOG_FILE || config.MemoryUsageLogService.LOG_FILE;
        config.MemoryUsageLogService.LOG_FILE = memoryUsageLogFile;
        let enableTraceGC = options.enable_trace_gc || process.env.ROOKOUT_ENABLE_TRACE_GC || config.MemoryUsageLogService.TRACE_GC_ENABLED;
        config.MemoryUsageLogService.TRACE_GC_ENABLED = enableTraceGC;
        let legacyLiveTailEnvVar = process.env.ROOKOUT_LIVE_TAIL;
        let liveTailEnvVar = process.env.ROOKOUT_LIVE_LOGGER;
        let consoleLiveLoggerEnvVar = process.env.ROOKOUT_CONSOLE_LIVE_LOGGER;
        let liveTailProp = options.live_logger;
        let legacyLiveTailProp = options.enable_livetail;
        let enableLiveTail = liveTailProp || legacyLiveTailProp || liveTailEnvVar || legacyLiveTailEnvVar || consoleLiveLoggerEnvVar || config.LogHandlerService.ENABLED || config.LogHandlerService.CONSOLE_FUNCTIONS_HOOK_ENABLED;
        config.LogHandlerService.ENABLED = enableLiveTail;

        if (enableLiveTail) {
          config.LogHandlerService.CONSOLE_FUNCTIONS_HOOK_ENABLED = process.env.ROOKOUT_CONSOLE_LIVE_LOGGER || config.LogHandlerService.CONSOLE_FUNCTIONS_HOOK_ENABLED;

          if (options.labels) {
            options.labels["live_logger"] = "on";
          } else {
            options.labels = {
              "live_logger": "on"
            };
          }
        }

        let heapSnapshotsDirectory = options.heap_snapshots_directory || process.env.ROOKOUT_HEAP_SNAPSHOTS_DIRECTORY;

        if (heapSnapshotsDirectory) {
          config.HeapSnapshotConfiguration.HEAP_PATH = heapSnapshotsDirectory;
          config.HeapSnapshotConfiguration.SIGNAL = options.heap_snapshots_signal || process.env.ROOKOUT_HEAP_SNAPSHOTS_SIGNAL || config.HeapSnapshotConfiguration.SIGNAL;
        }

        let host = options.host || process.env.ROOKOUT_CONTROLLER_HOST || process.env.ROOKOUT_AGENT_HOST;
        let port = options.port || process.env.ROOKOUT_CONTROLLER_PORT || process.env.ROOKOUT_AGENT_PORT;
        let proxy = options.proxy || process.env.ROOKOUT_PROXY;
        let token = options.token || process.env.ROOKOUT_TOKEN;

        if (proxy !== undefined) {
          Rook._verifyString(proxy, 'proxy should be a string');
        }

        const {
          logger
        } = require('./logger');

        logger.debug(util.format('Rookout SDK [%s]:[%s] for NodeJS [%s]', config.VersionConfiguration.VERSION, config.VersionConfiguration.COMMIT, process.versions.node));

        if (host === undefined && token === undefined) {
          throw new RookMissingToken();
        } else {
          if (token !== undefined) {
            Rook._verifyToken(token);
          }
        }

        if (this.debug) {
          Rook._print_options({
            token: token !== undefined ? token.substring(0, 5) + "....." : undefined,
            host: host,
            port: port,
            proxy: proxy,
            throw_errors: self.throw_errors,
            log_level: options.log_level,
            log_to_stderr: options.log_to_stderr,
            log_file: options.log_file,
            git_commit: options.git_commit,
            git_origin: options.git_origin,
            sources: options.sources,
            tags: options.tags,
            live_logger: options.live_logger,
            labels: options.labels
          });
        }

        host = host || config.ControllerAddress.HOST;

        Rook._verifyString(host, 'Rook host should be String');

        if (host === "staging.cloud.agent.rookout.com" || host === "cloud.agent.rookout.com") {
          throw new RookOldServers();
        }

        port = port || config.ControllerAddress.PORT;

        if (!(typeof port === 'number' || typeof port === 'string')) {
          throw new RookInvalidOptions('Rook port should be a Number or a String');
        }

        if (process.env.ROOKOUT_CONNECTION_TIMEOUT !== undefined) {
          if (typeof process.env.ROOKOUT_CONNECTION_TIMEOUT === 'number') {
            config.AgentComConfiguration.TIMEOUT = process.env.ROOKOUT_CONNECTION_TIMEOUT;
          }
        }

        this.savedOptions = options;
        self.singleton = require('./singleton').singleton;
        self.singleton.connect(token, host, port, proxy, options.tags, options.labels, this.debug, this.throw_errors).catch(e => {
          if (self.throw_errors) {
            reject(e);
          } else {
            if (e instanceof RookInvalidToken || e instanceof RookOldServers || e instanceof _exceptions.RookIllegalLambdaStart) {
              console.log('[Rookout] ', e.message);
            } else {
              console.error('[Rookout] Failed to connect to the controller - will continue attempting in the background: ', e.message);
            }

            if (self.debug) {
              console.error(e.stack || e);
            }

            resolve(self);
          }
        }).then(() => resolve(self));
      } catch (e) {
        if (self.throw_errors) {
          reject(e);
        } else {
          console.error('[Rookout] Failed to start Rookout: ', e.message);

          if (self.debug) {
            console.error(e.stack || e);
          }

          resolve(self);
        }
      }
    });
  }

  async stop() {
    if (!this.singleton) return;

    try {
      const singleton = this.singleton;
      this.singleton = undefined;
      await singleton.close();
    } catch (e) {
      if (this.throw_errors) {
        throw e;
      }

      if (this.debug) {
        console.error(e.stack || e);
      }
    }
  }

  flush(callback) {
    if (!this.singleton) {
      if (callback !== undefined) {
        callback();
      }

      return;
    }

    try {
      this.singleton.flush(callback);
    } catch (e) {
      if (this.throw_errors) {
        throw e;
      }

      if (this.debug) {
        console.error(e.stack || e);
      }
    }
  }

  notifyLambdaActive(context) {
    if (!this.singleton) {
      console.error('[Rookout] Initialization error');
      return;
    }

    this.singleton.notifyLambdaActive(context);
  }

  notifyLambdaInactive() {
    if (!this.singleton) {
      console.error('[Rookout] Initialization error');
      return;
    }

    this.singleton.notifyLambdaInactive();
  }

  static _print_options(options = {}) {
    try {
      let config_string = "";

      for (let key in options) {
        if (options[key] !== undefined) {
          config_string = config_string + key + ": " + options[key] + ", ";
        }
      }

      console.log("RookOptions: " + config_string);
    } catch (e) {}
  }

  static _verifyBoolean(object, errorString) {
    if (!(typeof object === 'boolean')) {
      throw new RookInvalidOptions(errorString);
    }
  }

  static _verifyString(object, errorString) {
    if (!(typeof object === 'string' || object instanceof String)) {
      throw new RookInvalidOptions(errorString);
    }
  }

  static _verifyToken(object) {
    Rook._verifyString(object, 'Rookout token should be a String');

    if (object.length !== 64) {
      throw new RookInvalidOptions('Rookout token should be 64 characters');
    }

    if (/^[0-9a-zA-Z]+$/.test(object) === false) {
      throw new RookInvalidOptions('Rookout token must consist of only hexadecimal characters');
    }
  }

  static _verifyLabel(label) {
    if (label.startsWith("$")) {
      throw new _exceptions.RookInvalidLabel(label);
    }
  }

  static checkVersionSupported() {
    if (!process || !process.versions || !process.versions.node) {
      throw new RookUnsupportedRuntime();
    }

    let nodeVersion = process.versions.node;
    let version = nodeVersion.split(".");

    if (version.length < 3) {
      throw new RookUnsupportedRuntime();
    }

    let processMajorVersion = parseInt(version[0]);
    let processMinorVersion = parseInt(version[1]);
    let processPatchVersion = parseInt(version[2]); // Validating not 8.9.1

    if (processMajorVersion === 8 && processMinorVersion === 9 && processPatchVersion === 1 || // Validating that 8.0.0 <= currentProcessVersion <= 12.22.7
    !(Rook.isVersionBiggerOrEqual(processMajorVersion, processMinorVersion, processPatchVersion, 8, 0, 0) && Rook.isVersionBiggerOrEqual(12, 22, 7, processMajorVersion, processMinorVersion, processPatchVersion)) && // Validating that 14.0.0 <= currentProcessVersion <= 14.18.1 
    !(Rook.isVersionBiggerOrEqual(processMajorVersion, processMinorVersion, processPatchVersion, 14, 0, 0) && Rook.isVersionBiggerOrEqual(14, 18, 1, processMajorVersion, processMinorVersion, processPatchVersion)) && // Validating that 16.0.0 <= currentProcessVersion <= 16.13.1 
    !(Rook.isVersionBiggerOrEqual(processMajorVersion, processMinorVersion, processPatchVersion, 16, 0, 0) && Rook.isVersionBiggerOrEqual(16, 13, 1, processMajorVersion, processMinorVersion, processPatchVersion))) {
      throw new RookUnsupportedNodeVersion(nodeVersion);
    }
  }

  static isVersionBiggerOrEqual(biggerMajor, biggerMinor, biggerPatch, smallerMajor, smallerMinor, smallerPatch) {
    return biggerMajor > smallerMajor || biggerMajor === smallerMajor && (biggerMinor > smallerMinor || biggerMinor === smallerMinor && biggerPatch >= smallerPatch);
  }

  static parseSourcesList(sourcesList) {
    if (sourcesList === undefined) {
      let sources = process.env.ROOKOUT_SOURCES;

      if (sources !== undefined) {
        sourcesList = {};

        for (let source of sources.replace(/['"]/g, '').split(';')) {
          let kv = source.split('#');

          if (kv.length === 2) {
            let origin = kv[0];
            let revision = kv[1];

            if (origin && revision) {
              sourcesList[origin] = revision;
            }
          }
        }
      }
    } else {
      // Normalize the map to native dictionary
      if (sourcesList instanceof Map) {
        let originalSources = sourcesList;
        sourcesList = {};

        for (let [origin, revision] of originalSources) {
          sourcesList[origin] = revision;
        }
      }

      for (let origin of Object.keys(sourcesList)) {
        Rook._verifyString(origin, 'Remote origin in source list should be a string');

        Rook._verifyString(sourcesList[origin], 'Revision in source list should be a string');
      }
    }

    return sourcesList;
  }

}

module.exports = Rook;
//# sourceMappingURL=interface.js.map
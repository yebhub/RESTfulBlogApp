"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logger = require("../logger");

var _RookError = _interopRequireDefault(require("./RookError"));

var _ContainerNamespace = _interopRequireDefault(require("./namespaces/ContainerNamespace"));

var _JSObjectNamespace = _interopRequireDefault(require("./namespaces/JSObjectNamespace"));

var _ListNamespace = _interopRequireDefault(require("./namespaces/ListNamespace"));

var _InspectorTracebackNamespace = require("./namespaces/InspectorTracebackNamespace");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const variant_pb = require('../protobuf/variant_pb');

const timestamp_pb = require('google-protobuf/google/protobuf/timestamp_pb');

function isFloat(n) {
  try {
    // This seems to throw sometimes :(
    return n === +n && n !== (n | 0);
  } catch (e) {
    return false;
  }
}

class NamespaceSerializer {
  constructor(useStringCache = false) {
    this.useStringCache = useStringCache;
    this.stringCache = {};

    if (useStringCache) {
      // Lock the 0 index since some variant will have no originalType (container for example)
      this.stringCache[""] = 0;
    }
  }

  getStringCache() {
    return this.stringCache;
  }

  dumps(namespace, logErrors = true) {
    let variant = new variant_pb.Variant();
    this.dump(namespace, variant, logErrors);
    return variant;
  }

  dump(namespace, variant, logErrors = true) {
    try {
      if (namespace instanceof _ContainerNamespace.default) {
        this.dumpContainerNamespace(namespace, variant, logErrors);
      } else if (namespace instanceof _JSObjectNamespace.default) {
        this.dumpJSObjectNamespace(namespace, variant, logErrors);
      } else if (namespace instanceof _ListNamespace.default) {
        this.dumpListNamespace(namespace, variant, logErrors);
      } else if (namespace instanceof _InspectorTracebackNamespace.InspectorTracebackNamespace) {
        this.dumpInspectorTracebackNamespace(namespace, variant);
      } else {
        throw new TypeError("Does not support serializing this type: " + typeof namespace);
      }
    } catch (e) {
      const message = "Failed to serialize namespace";
      this.clearVariant(variant);
      variant.setVariantType(variant_pb.Variant.Type.VARIANT_ERROR);

      if (logErrors) {
        variant.setErrorValue(new _RookError.default(e, message).dumps());

        _logger.logger.exception(message, e);
      }
    }
  }

  dumpContainerNamespace(namespace, variant, logErrors) {
    variant.setVariantType(variant_pb.Variant.Type.VARIANT_NAMESPACE);
    let result = new variant_pb.Variant.Namespace();

    for (let key of Object.keys(namespace.namespaces)) {
      let value = new variant_pb.Variant.NamedValue();
      value.setName(key);
      value.setValue(this.dumps(namespace.namespaces[key], logErrors));
      result.addAttributes(value);
    }

    variant.setNamespaceValue(result);
  }

  dumpJSObjectNamespace(namespace, variant, logErrors) {
    this.dumpJSObject(namespace.obj, variant, 0, namespace.dumpConfig, logErrors);
  }

  unsafeDumpJSObject(obj, variant, currentDepth, dumpConfig, logErrors) {
    if (currentDepth >= dumpConfig.maxDepth) {
      this.dumpMaxDepth(obj, variant, currentDepth, dumpConfig);
      return;
    }

    this.dumpBaseObject(obj, variant, currentDepth, dumpConfig, logErrors);

    if (undefined === obj) {
      variant.setVariantType(variant_pb.Variant.Type.VARIANT_UNDEFINED);
      return;
    }

    if (null === obj) {
      variant.setVariantType(variant_pb.Variant.Type.VARIANT_NONE);
      return;
    }

    if (obj === true || obj === false) {
      variant.setVariantType(variant_pb.Variant.Type.VARIANT_INT);
      variant.setIntValue(obj ? 1 : 0);
      return;
    } // isFloat is not including int


    if (isFloat(obj) || Number.isInteger(obj)) {
      variant.setVariantType(variant_pb.Variant.Type.VARIANT_DOUBLE);
      variant.setDoubleValue(obj);
      return;
    }

    if (typeof obj === 'string' || obj instanceof String) {
      variant.setVariantType(variant_pb.Variant.Type.VARIANT_STRING);
      let string = new variant_pb.Variant.String();
      string.setOriginalSize(obj.length);

      if (obj.length > dumpConfig.maxString) {
        if (!this.useStringCache) {
          string.setValue(obj.substring(0, dumpConfig.maxString));
        } else {
          string.setValueIndexInCache(this.getStringIndexInCache(obj.substring(0, dumpConfig.maxString)));
        }
      } else {
        if (!this.useStringCache) {
          string.setValue(obj);
        } else {
          string.setValueIndexInCache(this.getStringIndexInCache(obj));
        }
      }

      variant.setStringValue(string);
      return;
    }

    if (obj instanceof Date) {
      variant.setVariantType(variant_pb.Variant.Type.VARIANT_TIME);
      let date = new timestamp_pb.Timestamp();

      if (isNaN(obj.getTime())) {
        // date is not valid
        obj = new Date(0);
      }

      date.fromDate(obj);
      variant.setTimeValue(date);
      return;
    }

    if (Array.isArray(obj)) {
      this.dumpArray(obj, variant, currentDepth, dumpConfig, logErrors);
      return;
    }

    if (obj instanceof Error) {
      this.dumpException(obj, variant, currentDepth, dumpConfig, logErrors);
      return;
    }

    if (typeof obj === 'function') {
      variant.setVariantType(variant_pb.Variant.Type.VARIANT_CODE_OBJECT);
      let codeValue = new variant_pb.Variant.CodeObject();
      codeValue.setName(obj.name);
      variant.setCodeValue(codeValue);
      return;
    }

    this.dumpUserClass(obj, variant, currentDepth, dumpConfig, logErrors);
  }

  dumpJSObject(obj, variant, currentDepth, dumpConfig, logErrors) {
    try {
      this.unsafeDumpJSObject(obj, variant, currentDepth, dumpConfig, logErrors);
    } catch (e) {
      const message = "Failed to serialize object";
      this.clearVariant(variant);
      variant.setVariantType(variant_pb.Variant.Type.VARIANT_ERROR);

      if (logErrors) {
        variant.setErrorValue(new _RookError.default(e, message).dumps());

        _logger.logger.exception(message, e);
      }
    }
  }

  dumpMaxDepth(variant) {
    variant.setVariantType(variant_pb.Variant.Type.VARIANT_MAX_DEPTH);
  }

  setMaxDepthFlag(variant) {
    variant.setMaxDepth(true);
  }

  dumpBaseObject(obj, variant, currentDepth, dumpConfig) {
    // Try to get class name from prototype, if possible
    if (!this.useStringCache) {
      try {
        variant.setOriginalType(obj.__proto__.constructor.name);
      } catch (e) {
        variant.setOriginalType(typeof obj);
      }
    } else {
      try {
        variant.setOriginalTypeIndexInCache(this.getStringIndexInCache(obj.__proto__.constructor.name));
      } catch (e) {
        variant.setOriginalTypeIndexInCache(this.getStringIndexInCache(typeof obj));
      }
    }

    if (null === obj || undefined === obj) {
      return;
    } // Don't dump values of strings or arrays as they cause issues


    if (typeof obj === 'string' || obj instanceof String) {
      return;
    }

    let symbols = Object.getOwnPropertySymbols(obj);
    let objectKeys = Object.keys(obj);
    let objectWidth = symbols.length + objectKeys.length;
    let objectWeight = currentDepth + (objectWidth >= dumpConfig.maxWidth ? 2 : 1);

    if (objectWeight >= dumpConfig.maxDepth) {
      if (objectWidth) {
        this.setMaxDepthFlag(variant);
      }

      return;
    }

    for (let key of objectKeys) {
      if (obj[key] === obj) {
        continue;
      } // If it's an Array, ignore it's index attributes


      if (Array.isArray(obj) && parseInt(key).toString() === key) {
        continue;
      }

      let value = new variant_pb.Variant();

      if ('get' in Object.getOwnPropertyDescriptor(obj, key)) {
        value.setVariantType(variant_pb.Variant.Type.VARIANT_DYNAMIC);
      } else {
        this.dumpJSObject(obj[key], value, objectWeight, dumpConfig);
      }

      let attribute = new variant_pb.Variant.NamedValue();
      attribute.setName(key);
      attribute.setValue(value);
      variant.addAttributes(attribute);
    } // Protect against primitives pointing to themselves


    for (let index in symbols) {
      let symbol = symbols[index];
      let symbolName = symbol.toString();
      let value = new variant_pb.Variant();
      this.dumpJSObject(obj[symbol], value, objectWeight, dumpConfig);
      let attribute = new variant_pb.Variant.NamedValue();
      attribute.setName(symbolName);
      attribute.setValue(value);
      variant.addAttributes(attribute);
    }
  }

  dumpArray(obj, variant, currentDepth, dumpConfig, logErrors) {
    variant.setVariantType(variant_pb.Variant.Type.VARIANT_LIST);
    let list = new variant_pb.Variant.List();
    list.setType(_ListNamespace.default.getCommonType(list));
    list.setOriginalSize(obj.length);

    if (currentDepth < dumpConfig.maxCollectionDepth) {
      const maxItems = Math.min(obj.length, dumpConfig.maxWidth);

      for (let i = 0; i < maxItems; ++i) {
        let item = new variant_pb.Variant();
        this.dumpJSObject(obj[i], item, currentDepth + 1, dumpConfig, logErrors);
        list.addValues(item);
      }
    }

    variant.setListValue(list);
  }

  dumpException(obj, variant, currentDepth, dumpConfig, logErrors) {
    variant.setVariantType(variant_pb.Variant.Type.VARIANT_OBJECT);
    let messageValue = new variant_pb.Variant();
    this.dumpJSObject(obj.message, messageValue, currentDepth + 1, dumpConfig, logErrors);
    let messagePair = new variant_pb.Variant.NamedValue();
    messagePair.setName('message');
    messagePair.setValue(messageValue);
    variant.addAttributes(messagePair);
    let stackValue = new variant_pb.Variant();
    this.dumpJSObject(obj.stack, stackValue, currentDepth + 1, dumpConfig, logErrors);
    let stackPair = new variant_pb.Variant.NamedValue();
    stackPair.setName('stack');
    stackPair.setValue(stackValue);
    variant.addAttributes(stackPair);
  }

  dumpUserClass(obj, variant, currentDepth, dumpConfig) {
    variant.setVariantType(variant_pb.Variant.Type.VARIANT_OBJECT);
  }

  dumpListNamespace(namespace, variant, logErrors) {
    variant.setVariantType(variant_pb.Variant.Type.VARIANT_LIST);
    variant.setOriginalType(namespace.originalType);
    let listValue = new variant_pb.Variant.List();
    listValue.setType(namespace.commonType);
    listValue.setOriginalSize(namespace.originalSize);

    for (let item of namespace.list) {
      listValue.addValues(this.dumps(item, logErrors));
    }

    variant.setListValue(listValue);
  }

  dumpInspectorTracebackNamespace(namespace, variant) {
    if (!this.useStringCache) {
      namespace.dump(variant, null);
    } else {
      namespace.dump(variant, this);
    }
  }

  dumpInspectorArray(namespace, variant, currentDepth, dumpConfig, logErrors) {
    variant.setVariantType(variant_pb.Variant.Type.VARIANT_LIST);
    const lengthString = namespace.obj.description.match(/\((\d+)\)/)[1];
    const length = parseInt(lengthString);
    let list = new variant_pb.Variant.List();
    list.setType(_ListNamespace.default.getCommonType(list));
    list.setOriginalSize(length);
    const maxItems = Math.min(length, dumpConfig.maxWidth);

    if (currentDepth < dumpConfig.maxCollectionDepth) {
      for (let i = 0; i < maxItems; ++i) {
        let obj = null; // Sparse arrays have missing objects as undefined

        try {
          obj = namespace.readAttribute(i.toString());
        } catch (e) {
          obj = new _JSObjectNamespace.default(undefined);
        }

        let item = new variant_pb.Variant();

        if (obj instanceof InspectorObjectNamespace) {
          this.dumpInspectorObjectNamespace(obj, item, currentDepth + 1, dumpConfig, logErrors);
        } else {
          this.dumpJSObject(obj.obj, item, currentDepth + 1, dumpConfig, logErrors);
        }

        list.addValues(item);
      }
    }

    variant.setListValue(list);
  }

  dumpInspectorDate(namespace, variant, currentDepth, dumpConfig) {
    variant.setVariantType(variant_pb.Variant.Type.VARIANT_TIME);
    let date = new timestamp_pb.Timestamp();
    let timeValue = namespace.obj.description;

    if (isNaN(timeValue.getTime())) {
      // date is not valid
      timeValue = new Date(0);
    }

    date.fromDate(new Date(timeValue));
    variant.setTimeValue(date);
  }

  clearVariant(variant) {
    variant.setVariantType(undefined);
    variant.setOriginalType(undefined);
    variant.clearAttributesList();
    variant.clearIntValue();
    variant.clearLongValue();
    variant.clearDoubleValue();
    variant.clearStringValue();
    variant.clearListValue();
    variant.clearMapValue();
    variant.clearNamespaceValue();
    variant.clearErrorValue();
    variant.clearMessageValue();
    variant.clearTimeValue();
    variant.clearCodeValue();
    variant.clearLargeIntValue();
    variant.clearComplexValue();
  }

  getStringIndexInCache(str) {
    if (str in this.stringCache) {
      return this.stringCache[str];
    }

    let currentSize = Object.keys(this.stringCache).length;
    this.stringCache[str] = currentSize;
    return currentSize;
  }

}

exports.default = NamespaceSerializer;
//# sourceMappingURL=NamespaceSerializer.js.map
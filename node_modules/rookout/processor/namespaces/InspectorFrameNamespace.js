"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Namespace = _interopRequireDefault(require("./Namespace"));

var _JSObjectNamespace = _interopRequireWildcard(require("./JSObjectNamespace"));

var _exceptions = require("../../exceptions");

var _ContainerNamespace = _interopRequireDefault(require("./ContainerNamespace"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const extractor = `
    function copy(index) {
      let scopes = process.__rookout_backchannel.get(index).scopes;
      scopes[scopes.length - 1].object = this;
     }
`;

class InspectorFrameNamespace extends _Namespace.default {
  constructor(inspector, frame) {
    super();
    this.inspector = inspector;
    this.frame = frame;
    this.scopes = null;
    this.this = undefined;
    this.position = null;
  }

  readAttribute(name) {
    const session = this.inspector;

    const index = process.__rookout_backchannel.add();

    let error = false;

    try {
      session.post('Debugger.evaluateOnCallFrame', {
        callFrameId: this.frame.callFrameId,
        expression: `process.__rookout_backchannel.get(${index}).attr = ${name};`,
        objectGroup: "backtrace"
      }, ret => {
        if (ret && ret.exceptionDetails) {
          error = true;
        }
      });

      if (error) {
        throw new _exceptions.RookAttributeNotFound(name);
      } else {
        return new _JSObjectNamespace.default(process.__rookout_backchannel.get(index).attr);
      }
    } finally {
      process.__rookout_backchannel.delete(index);
    }
  }

  callMethod(name, args) {
    switch (name) {
      case "filename":
      case "module":
        return this.filename();

      case "line":
        return this.line();

      case "function":
      case "method":
        return this.function();

      case "locals":
        return this.locals(args);

      case "dump":
        return this.dump(args);

      default:
        return super.callMethod(name, args);
    }
  }

  filename() {
    return new _JSObjectNamespace.default(this.getPosition().filename);
  }

  module() {
    return this.filename();
  }

  line() {
    return new _JSObjectNamespace.default(this.getPosition().line);
  }

  function() {
    return new _JSObjectNamespace.default(this.getPosition().function);
  }

  locals(args) {
    this.populateScopes();
    let result = {};
    let depth = null;
    let dumpConfig = null;

    if (null != args && '' !== args) {
      depth = parseInt(args);

      if (isNaN(depth)) {
        depth = null;
        dumpConfig = _JSObjectNamespace.dumpConfigs[args.toLowerCase()];

        if (dumpConfig === undefined) {
          throw new _exceptions.RookInvalidMethodArguments('locals()', args);
        }
      }
    }

    for (let i = this.scopes.length - 1; i >= 0; i--) {
      for (let k of Object.keys(this.scopes[i].object)) {
        result[k] = new _JSObjectNamespace.default(this.scopes[i].object[k], dumpConfig);

        if (depth !== null && dumpConfig == null) {
          result[k].dumpConfig.maxDepth = depth;
        }
      }
    }

    result.this = new _JSObjectNamespace.default(this.this);
    return new _ContainerNamespace.default(result);
  }

  dump(args) {
    return new _ContainerNamespace.default({
      locals: this.locals(args),
      module: this.module(),
      filename: this.filename(),
      line: this.line(),
      function: this.function()
    });
  }

  getPosition() {
    if (this.position === null) {
      this.position = this.inspector.resolvePosition(this.frame);
    }

    return this.position;
  }

  populateScopes() {
    if (this.scopes !== null) {
      return this.scopes;
    }

    let scopes = [];
    let session = this.inspector;

    let index = process.__rookout_backchannel.add();

    try {
      let context = process.__rookout_backchannel.get(index);

      let scopeChain = this.frame.scopeChain;
      context.scopes = [];

      for (let scopeId = 0; scopeId < scopeChain.length; scopeId++) {
        let remoteScope = scopeChain[scopeId];
        let nextRemoteScope = scopeChain[scopeId + 1];
        let active = remoteScope.type === 'local' || remoteScope.type === 'catch' || remoteScope.type === 'block' || remoteScope.type === 'closure' && (nextRemoteScope === undefined || nextRemoteScope.type !== 'global');
        if (!active) continue;
        let scope = {};
        scope.type = remoteScope.type;
        scope.object = {};
        context.scopes.push(scope);
        let error = null;
        session.post('Runtime.callFunctionOn', {
          objectId: remoteScope.object.objectId,
          functionDeclaration: extractor,
          arguments: [{
            value: index
          }],
          objectGroup: "backtrace"
        }, e => {
          error = e;
        });

        if (error !== null) {
          throw error;
        }

        scopes = context.scopes;
      }

      session.post('Runtime.callFunctionOn', {
        objectId: this.frame.this.objectId,
        functionDeclaration: `
                        function copy() {
                          process.__rookout_backchannel.get(${index}).this = this;
                         }
                        `,
        objectGroup: "backtrace"
      });

      let _this = process.__rookout_backchannel.get(index).this;

      if (_this === global) {
        _this = undefined;
      }

      this.this = _this;
    } finally {
      process.__rookout_backchannel.delete(index);

      this.scopes = scopes;
    }

    return this.scopes;
  }

}

exports.default = InspectorFrameNamespace;
//# sourceMappingURL=InspectorFrameNamespace.js.map
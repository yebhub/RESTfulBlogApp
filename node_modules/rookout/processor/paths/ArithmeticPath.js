"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _JSObjectNamespace = _interopRequireDefault(require("../namespaces/JSObjectNamespace"));

var _exceptions = require("../../exceptions");

var _ContainerNamespace = _interopRequireDefault(require("../namespaces/ContainerNamespace"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const exceptions = require('../../exceptions');

/*
Canopy is used to build and evaluate a tree of operations.
a .peg file (Rookout/canopy/ArithmeticPath.peg) is compiled into the various rooks languages.
Canopy is a PEG parser compiler - and i extend its goal to actually evaluate our arithmetic paths.
 */
const maps = require('./ArithmeticPathInternal');

const ops = new Map([["NE", "!="], ["=", "=="], ["EQ", "=="], ["LT", "<"], ["GT", ">"], ["GE", ">="], ["LE", "<="], ["AND", "&&"], ["OR", "||"]]);
const level1 = ["*", "/"];
const level2 = ["+", "-"];
const level3 = ["<=", ">=", "!=", "=", "==", ">", "<", "LT", "GT", "LE", "GE", "EQ", "NE", "lt", "gt", "le", "ge", "eq", "ne"];
const level4 = ["in", "IN"];
const level5 = ["or", "OR", "||", "and", "AND", "&&"];
const allLevels = [level1, level2, level3, level4, level5];

class Marker {
  write(namespace, value) {
    throw new _exceptions.RookOperationReadOnly("Marker");
  }

}

class FunctionOperation extends Marker {
  constructor(funcName, funcArgs) {
    super();
    this.funcName = funcName;
    this.funcArgs = funcArgs;
  }

  read(namespace, create) {
    return namespace.callMethod(this.funcName, this.funcArgs);
  }

}

class AttributeOperation extends Marker {
  constructor(name) {
    super();
    this.name = name;
  }

  read(namespace, create) {
    if (namespace === null) {
      throw new _exceptions.RookAttributeNotFound(this.name);
    }

    try {
      return namespace.readAttribute(this.name);
    } catch (e) {
      if (create && e instanceof _exceptions.RookAttributeNotFound) {
        namespace.writeAttribute(this.name, new _ContainerNamespace.default({}));
        return namespace.readAttribute(this.name);
      } else {
        throw e;
      }
    }
  }

  write(namespace, value) {
    return namespace.writeAttribute(this.name, value);
  }

}

class LookupOperation extends Marker {
  constructor(name) {
    super();

    if (name.length > 1 && name[0] === "'" && name[name.length - 1] === "'") {
      this.name = name.substring(1, name.length - 1);
    } else if (name.length > 1 && name[0] === '"' && name[name.length - 1] === '"') {
      this.name = name.substring(1, name.length - 1);
    } else {
      this.name = Number(name);
    }
  }

  read(namespace, create) {
    return namespace.readKey(this.name);
  }

  write(namespace, value) {
    throw (0, _exceptions.RookOperationReadOnly)("LookupOperation");
  }

}

class OperationList extends Marker {
  constructor(list) {
    super();
    this.list = list;
  }

  read(namespace, create) {
    try {
      // execute the operation chain.
      for (let i = 0; i < this.list.length; i++) {
        namespace = this.list[i].read(namespace, create);
      }

      if (!actions.is_primitive(namespace.obj) && !Array.isArray(namespace.obj)) {
        return new NonPrimitiveNamespaceResult(namespace, "<missing>");
      }

      return new NamespaceResult(namespace);
    } catch (e) {
      return new ToolException_(e);
    }
  }

  write(namespace, value) {
    // Verify the path is valid for writing
    const size = this.list.length;

    if (size === 0) {
      throw new exceptions.RookInvalidArithmeticPath(this.expression, null);
    } // execute the operation chain.


    let i = 0;

    for (; i < size - 1; i++) {
      namespace = this.list[i].read(namespace, true);
    }

    return this.list[i].write(namespace, value);
  }

  get_obj(namespace) {
    const result = this.read(namespace, false);

    if (undefined != result.get_obj) {
      return result.get_obj();
    } else {
      return result;
    }
  }

}

class ToolException_ extends Marker {
  constructor(exc) {
    super();
    this.obj = exc;
  }

  toString() {
    return this.obj.toString();
  }

}

class ObjectMarker extends Marker {
  read(namespace, create) {
    return this;
  }

}

class NamespaceResult extends ObjectMarker {
  constructor(namespace) {
    super();
    this.obj = namespace;
    this.text_ready = false;
    this.text = null;
  }

  toString() {
    if (!this.text_ready) {
      if (this.obj.obj === undefined) {
        this.text = "'undefined'";
      } else {
        if (this.obj.obj === null) {
          this.text = "'null'";
        } else {
          this.text = this.obj.obj.toString();
        }
      }

      this.text_ready = true;
    }

    return this.text;
  }

  get_obj() {
    return this.obj.obj;
  }

}

class NonPrimitiveNamespaceResult extends NamespaceResult {
  constructor(namespace, path) {
    super(namespace);
    this.path = path;
  }

  toString() {
    return 'NonPrimitiveNamespaceResult';
  }

}

class SimpleObjectMarker extends ObjectMarker {
  constructor(obj) {
    super();
    this.obj = obj;
  }

  toString() {
    return this.obj.toString();
  }

  get_obj() {
    return this.obj;
  }

}

class Text extends ObjectMarker {
  constructor(str) {
    super();
    this.obj = str;
  }

  toString() {
    return this.obj;
  }

  get_obj() {
    return this.obj;
  }

}

class Array_ extends ObjectMarker {
  constructor(list, str) {
    super();
    this.obj = list;
    this.text = str;
  }

  toString() {
    return this.text;
  }

  get_obj() {
    return this.obj;
  }

}

class Bool extends ObjectMarker {
  constructor(bool) {
    super();
    this.obj = bool === 'true' || bool === 'True' || bool === true;
  }

  toString() {
    return this.obj.toString();
  }

  get_obj() {
    return this.obj;
  }

}

const boolFalse = new Bool(false);
const boolTrue = new Bool(true);

class Null extends ObjectMarker {
  constructor() {
    super();
    this.obj = null;
  }

  toString() {
    return 'null';
  }

  get_obj() {
    return this.obj;
  }

}

const nullInstance = new Null();

class Undefined extends ObjectMarker {
  constructor() {
    super();
    this.obj = undefined;
  }

  toString() {
    return 'undefined';
  }

  get_obj() {
    return this.obj;
  }

}

const undefinedInstance = new Undefined();

const _opMap = new Map([["+", function (a, b) {
  return a + b;
}], ["-", function (a, b) {
  return a - b;
}], ["/", function (a, b) {
  return a / b;
}], ["*", function (a, b) {
  return a * b;
}], ["<", function (a, b) {
  return a < b;
}], ["<=", function (a, b) {
  return a <= b;
}], [">", function (a, b) {
  return a > b;
}], [">=", function (a, b) {
  return a >= b;
}], ["!=", function (a, b) {
  return a !== b;
}], ["!==", function (a, b) {
  return a !== b;
}], ["=", function (a, b) {
  return a === b;
}], ["==", function (a, b) {
  return a === b;
}], ["===", function (a, b) {
  return a === b;
}], //"in": function(a, b) { return a in b; },lambda a, b: a in b,  # should use this...
["&&", function (a, b) {
  return a && b;
}], ["||", function (a, b) {
  return a || b;
}]]);

class Opt extends Marker {
  constructor(opt) {
    super();
    this.opt = opt;
    this.level = null;
    let optUpperCase = opt.toUpperCase();

    for (let [key, value] of ops) {
      if (key === optUpperCase) {
        this.opt = value;
        break;
      }
    }

    let level = 0;
    let found = false;

    for (let value of allLevels) {
      for (let innerValue of value) {
        if (opt === innerValue) {
          this.level = level;
          found = true;
          break;
        }
      }

      if (found) {
        break;
      }

      level += 1;
    }

    if (!found) {
      throw new exceptions.RookInvalidArithmeticPath("Condition could not be resolved: " + opt);
    }
  }

  executeOperation(namespace, a, b) {
    a = a.read(namespace);

    if (a instanceof ToolException_) {
      return a;
    }

    b = b.read(namespace);

    if (b instanceof ToolException_) {
      return b;
    }

    switch (this.level) {
      case 0:
      case 1:
      case 2:
      case 4:
        let result = _opMap.get(this.opt)(a.get_obj(namespace), b.get_obj(namespace));

        if (result.constructor === Boolean) {
          if (result === false) {
            if (a instanceof NonPrimitiveNamespaceResult) {
              if (!(b instanceof Undefined) && !(b instanceof Null)) {
                return new ToolException_(new _exceptions.RookNonPrimitiveObjectType(a.path));
              }
            }

            if (b instanceof NonPrimitiveNamespaceResult) {
              if (!(a instanceof Undefined) && !(a instanceof Null)) {
                return new ToolException_(new _exceptions.RookNonPrimitiveObjectType(b.path));
              }
            }

            return boolFalse;
          } else {
            return boolTrue;
          }
        }

        if (result instanceof Bool) {
          return result;
        }

        if (Number.isInteger(result)) {
          return new SimpleObjectMarker(result);
        }

        return new Text(result);

      case 3:
        if (b instanceof NonPrimitiveNamespaceResult) {
          return new ToolException_(new _exceptions.RookNonPrimitiveObjectType(b.path));
        }

        if (!(b instanceof Array_) && !(b instanceof NamespaceResult) && !(b instanceof Text)) {
          return boolFalse;
        }

        if (b.obj instanceof _JSObjectNamespace.default) {
          if (Array.isArray(b.obj.obj)) {
            for (let item of b.obj.obj) {
              if (item === a.obj) {
                return boolTrue;
              }
            }
          }

          if (typeof b.obj.obj === 'string') {
            if (a instanceof Text) {
              return b.obj.obj.includes(a.obj) ? boolTrue : boolFalse;
            } else {
              return b.obj.obj.includes(a.obj.obj) ? boolTrue : boolFalse;
            }
          }

          return boolFalse;
        } else {
          if (b instanceof Array_) {
            for (let itr of b.obj) {
              if (itr.toString() === a.toString() && itr.obj === a.obj) {
                return boolTrue;
              }
            }
          } else {
            if (b instanceof Text) {
              if (a.obj.constructor === String) {
                if (b.toString().includes(a.toString())) {
                  return boolTrue;
                }
              }
            } else {
              if (b instanceof NamespaceResult) {
                if (a.obj.constructor === String) {
                  if (b.toString().includes(a.toString())) {
                    return boolTrue;
                  }
                } else {
                  if (a instanceof NamespaceResult) {
                    if (b.toString().includes(a.toString())) {
                      return boolTrue;
                    }
                  }
                }
              }
            }
          }
        }

        return boolFalse;
    }
  }

}

class FlatOpt extends Marker {
  constructor(flatElements) {
    super();
    this.flatElements = flatElements;
  }

  read(namespace, create) {
    let flatElements = this.flatElements.slice();

    while (flatElements.length > 1) {
      let shouldStop = false;

      for (let level = 0; level < allLevels.length && !shouldStop; level++) {
        for (let i = 1; i < flatElements.length; i += 2) {
          let currentOpt = flatElements[i];

          if (currentOpt.level === level) {
            let result = currentOpt.executeOperation(namespace, flatElements[i - 1], flatElements[i + 1]);
            flatElements.splice(i - 1, 3);
            flatElements.splice(i - 1, 0, result);
            shouldStop = true;
            break;
          }
        }
      }
    }

    return flatElements[0];
  }

  get_obj(namespace) {
    const result = this.read(namespace, false);

    if (undefined != result.get_obj) {
      return result.get_obj();
    } else {
      return result;
    }
  }

}

class TreeFlatter {
  constructor() {
    this.flattedTree = [];
  }

  run(currentElement) {
    if (currentElement instanceof Marker) {
      this.flattedTree.push(currentElement);
    }

    for (let e of currentElement.elements) {
      if (e instanceof Marker) {
        this.flattedTree.push(e);
      } else {
        this.run(e);
      }
    }

    return this.flattedTree;
  }

}

class actions {
  constructor() {}

  make_lookup_operation(input, start, end, elements) {
    return new LookupOperation(input.substring(start + 1, end - 1));
  }

  make_function_operation(input, start, end, elements) {
    // To build the function name, we will merge the unicode_set and all the unicode_set_with_numbers
    // To build the args we will simply read the atom at index 3
    // which can be result of another operation; thus checking for exception
    // For further explanation, check ArithmeticPath.peg
    let functionName = elements[0].text + elements[1].text;

    if (elements[3] instanceof ToolException_) {
      throw elements[3];
    }

    let args = elements[3] instanceof Marker ? elements[3].toString() : elements[3].text;
    return new FunctionOperation(functionName, args);
  }

  make_function_operation_access(input, start, end, elements) {
    // To build the function name, we will merge the unicode_set and all the unicode_set_with_numbers
    // To build the args we will simply read the atom at index 4
    // which can be result of another operation; thus checking for exception
    // For further explanation, check ArithmeticPath.peg
    let functionName = elements[1].text + elements[2].text;

    if (elements[4] instanceof ToolException_) {
      throw elements[4];
    }

    let args = elements[4] instanceof Marker ? elements[4].toString() : elements[4].text;
    return new FunctionOperation(functionName, args);
  }

  make_attribute_operation(input, start, end, elements) {
    return new AttributeOperation(input.substring(start + 1, end));
  }

  make_attribute(input, start, end, elements) {
    return new AttributeOperation(input.substring(start, end));
  }

  static is_primitive(obj) {
    return !(obj !== undefined && obj !== null && obj.constructor !== Number && obj.constructor !== String && obj.constructor !== Boolean);
  }

  make_and_execute_namespace_operation(input, start, end, elements) {
    // Element 1 will not be null
    // Element 2 is a list of another elements (can be empty)
    // element1.(element2.element3.element4)
    // For further explanation, check ArithmeticPath.peg
    try {
      let operations = [];
      operations.push(elements[1]);

      for (let nn of elements[2].elements) {
        operations.push(nn);
      } // Check if we have some exceptions in the operations chain - might happen if function parsing failed.


      for (let op of operations) {
        if (op instanceof ToolException_) {
          return op;
        }
      } // As part of optimization, we don't actually execute the namespace here


      return new OperationList(operations);
    } catch (e) {
      return new ToolException_(e);
    }
  }

  make_comp_exp_ex(input, start, end, elements) {
    // Element 2 is the actual expression
    // For further explanation, check ArithmeticPath.peg
    return elements[2];
  }

  make_comp_exp(input, start, end, elements) {
    // We can assume the following: atom ( opt_ atom )*
    // the first (which must be) will be simple atom
    // the second and so forth will always be pair <Opt, Atom>
    // Its important to remember that this execution will handle the inner brackets if exist
    // In order to handle priority (which i could not figure out if available with canopy library):
    // 1. lets make the tree flat
    // 2. handle priority ourselves - (atom opt1 atom) will be handled before (atom opt2 atom) and will return TreeNode with result
    // For further explanation, check ArithmeticPath.peg
    // handle case the size is 1
    if (elements[1].elements.length === 0) {
      return elements[0];
    }

    let flatElements = [];
    flatElements.push(elements[0]);

    for (let nn of elements[1].elements) {
      flatElements.push(nn.elements[0]);
      flatElements.push(nn.elements[1]);
    }

    return new FlatOpt(flatElements);
  }

  make_opt(input, start, end, elements) {
    return new Opt(elements[1].text);
  }

  make_apostrophe_string(input, start, end, elements) {
    return new Text(elements[2].text);
  }

  make_string(input, start, end, elements) {
    return new Text(elements[2].text);
  }

  make_list(input, start, end, elements) {
    let flatter = new TreeFlatter();
    let result = flatter.run(elements[3]);
    return new Array_(result, input.substr(start, end));
  }

  make_float(input, start, end, elements) {
    return new SimpleObjectMarker(parseFloat(input.substring(start, end).split(" ").join("")));
  }

  make_number(input, start, end, elements) {
    return new SimpleObjectMarker(parseInt(input.substring(start, end).split(" ").join(""), 10));
  }

  make_char(input, start, end, elements) {
    return new SimpleObjectMarker(input.substring(start, end).split(" ").join(""));
  }

  make_bool(input, start, end, elements) {
    return new Bool(input.substring(start, end).split(" ").join(""));
  }

  make_null(input, start, end, elements) {
    return nullInstance;
  }

  make_undefined(input, start, end, elements) {
    return undefinedInstance;
  }

}

class ArithmeticPath {
  constructor(configuration) {
    this.negation = false;
    let string = null;

    if (typeof configuration === "string") {
      string = configuration;
    } else {
      string = configuration['path'];
    }

    if (string.startsWith("NOT(") && string.endsWith(")")) {
      string = string.substring("NOT(".length, string.length - 1);
      this.negation = true;
    }

    if (string === "") {
      throw new exceptions.RookInvalidArithmeticPath(string, null);
    }

    this.expression = string;
    this.actions = new actions();

    try {
      this.operations = maps.parse(this.expression, {
        actions: this.actions
      });
    } catch (e) {
      if (e instanceof ToolException_) {
        throw e.obj;
      }

      if (e instanceof _exceptions.ToolException) {
        throw e;
      }

      throw new exceptions.RookInvalidArithmeticPath(this.expression, e);
    }
  }

  readFrom(rootNamespace) {
    const result = this.operations.read(rootNamespace, false);
    return this.normalizeResult(result);
  }

  writeTo(rootNamespace, value) {
    this.operations.write(rootNamespace, value);
  }

  normalizeResult(result) {
    if (result instanceof Array_) {
      let newArr = [];

      for (let el of result.obj) {
        newArr.push(el.obj);
      }

      return new _JSObjectNamespace.default(newArr);
    }

    if (result instanceof NamespaceResult) {
      return result.obj;
    }

    if (result instanceof ToolException_) {
      throw result.obj;
    }

    if (result instanceof NonPrimitiveNamespaceResult) {
      return result.obj;
    }

    let res = result.obj;

    if (typeof res === 'boolean' && this.negation) {
      res = !res;
    }

    return new _JSObjectNamespace.default(res);
  }

}

exports.default = ArithmeticPath;
//# sourceMappingURL=ArithmeticPath.js.map
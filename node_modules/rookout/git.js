"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _wrapRegExp() { _wrapRegExp = function (re, groups) { return new BabelRegExp(re, undefined, groups); }; var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); _groups.set(_this, groups || _groups.get(re)); return _setPrototypeOf(_this, BabelRegExp.prototype); } _inherits(BabelRegExp, RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; if (typeof args[args.length - 1] !== "object") { args = [].slice.call(args); args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

const path = require('path');

const fs = require('fs');

const GIT_FOLDER = '.git';
const GIT_HEAD = 'HEAD';
const GIT_CONFIG = 'config';

class git {
  static isGit(pathToCheck) {
    return fs.existsSync(path.join(pathToCheck, GIT_FOLDER));
  }

  static findRoot(pathToCheck) {
    if (this.isGit(pathToCheck)) {
      return pathToCheck;
    }

    var nextPath = path.dirname(pathToCheck);

    if (nextPath !== pathToCheck) {
      return this.findRoot(nextPath);
    }

    return "";
  }

  static getRevision(pathToCheck) {
    return this.followSymLinks(path.join(pathToCheck, GIT_FOLDER), GIT_HEAD);
  }

  static getRemoteOrigin(pathToCheck) {
    const content = fs.readFileSync(path.join(pathToCheck, GIT_FOLDER, GIT_CONFIG), 'utf-8');
    const matches = content.match( /*#__PURE__*/_wrapRegExp(/\[remote "origin"\]\n[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*url[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*=[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]([\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uFEFE\uFF00-\uFFFF]*)/, {
      url: 1
    }));

    if (matches.groups !== undefined && matches.groups.url !== undefined) {
      return matches.groups.url;
    } else {
      return "";
    }
  }

  static followSymLinks(root, link) {
    var content = fs.readFileSync(path.join(root, link), 'utf-8');

    if (content.startsWith("ref:")) {
      var nextLink = content.split(' ')[1].trim();
      return this.followSymLinks(root, nextLink);
    } else {
      return content.trim();
    }
  }

}

exports.default = git;
//# sourceMappingURL=git.js.map
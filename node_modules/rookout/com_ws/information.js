"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cleanupAgentInfoPromise = cleanupAgentInfoPromise;
exports.collect = collect;
exports.pack_agent_info = pack_agent_info;

var _logger = require("../logger");

var _git = _interopRequireDefault(require("../git"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const agent_info_pb = require("../protobuf/agent_info_pb");

const os = require("os");

const ip = require("ip");

const path = require("path");

const getos = require("getos");

const config = require('../config');

const fs = require('fs'); // Kubernetes namespace related variables


const k8sNamespaceFileName_default = '/var/run/secrets/kubernetes.io/serviceaccount/namespace';
var k8sNamespaceFileName = k8sNamespaceFileName_default;

class Information {
  constructor() {
    if (this.constructor === Information) {
      throw new TypeError("Abstract class \"Information\" cannot be instantiated directly.");
    }

    this._collectors = this._getCollectors();
  } // Override this method without calling super.

  /* abstract */


  _getCollectors() {
    throw new TypeError("Inheriting classes must implement _getCollectors");
  } // k8sNamespaceFileNameOverride - override the default read location of the Kubernetes 
  // namespaceinformation. Use for debugging.


  async collect(debug) {
    let output = {};

    for (let key of Object.keys(this._collectors)) {
      let value = this._collectors[key];

      if (value instanceof Function) {
        value = value();
      }

      output[key] = await value;
    }

    output.debug = debug;
    return output;
  }

}

class SCMInformation extends Information {
  _getCollectors() {
    return {
      "commit": this._get_commit.bind(this),
      "origin": this._get_origin.bind(this),
      "sources": this._get_sources.bind(this)
    };
  }

  _get_sources() {
    return config.GitConfiguration.SOURCES || {};
  }

  _get_commit() {
    let userCommit = config.GitConfiguration.GIT_COMMIT || process.env.ROOKOUT_COMMIT || "";

    if (userCommit === "") {
      try {
        let gitRoot = this._get_git_root();

        if (gitRoot !== "") {
          if (userCommit === "") {
            userCommit = _git.default.getRevision(gitRoot);
          }

          return userCommit;
        }
      } catch (e) {
        _logger.logger.exception("Failed to get git commit");
      }

      return "";
    }

    return userCommit;
  }

  _get_git_root() {
    let gitRoot = process.env.ROOKOUT_GIT || "";

    if (gitRoot === "") {
      gitRoot = _git.default.findRoot(path.dirname(path.resolve(require.main.filename)));
    }

    return gitRoot;
  }

  _get_origin() {
    let userRemoteOrigin = config.GitConfiguration.GIT_ORIGIN || process.env.ROOKOUT_REMOTE_ORIGIN || "";

    if (userRemoteOrigin === "") {
      try {
        let gitRoot = this._get_git_root();

        if (gitRoot !== "") {
          if (userRemoteOrigin === "") {
            userRemoteOrigin = _git.default.getRemoteOrigin(gitRoot);
          }

          return userRemoteOrigin;
        }
      } catch (e) {
        _logger.logger.exception("Failed to get git remote origin");
      }

      return "";
    }

    return userRemoteOrigin;
  }

}

class PlatformInformation extends Information {
  _getCollectors() {
    return {
      "platform": "node",
      "version": process.version
    };
  }

}

class NetworkInformation extends Information {
  _getCollectors() {
    return {
      "ip_addr": ip.address,
      "network": os.hostname
    };
  }

}

class SystemInformation extends Information {
  _getCollectors() {
    return {
      "hostname": os.hostname,
      "os": os.platform,
      "os_version": os.release,
      "distro": this._getDistro,
      "arch": os.arch
    };
  }

  async _getDistro() {
    if (os.platform() !== "linux") {
      return "<NA>";
    }

    let distro = null;
    getos((e, os_info) => {
      if (e) {
        throw e;
      }

      distro = os_info.dist + " " + os_info.codename + " " + os_info.release;
      return distro;
    });
  }

}

class VersionInformation extends Information {
  _getCollectors() {
    return {
      "version": "0.41.0",
      "commit": "652ebf0e7b760e5f0f328ff866df80b62c2f5f61"
    };
  }

}

class ClusterInformation extends Information {
  _getCollectors() {
    // Check if the file exists, may also be a directory
    try {
      if (!fs.existsSync(k8sNamespaceFileName)) {
        return {
          "k8s_namespace": ""
        };
      }
    } catch (err) {
      return {
        "k8s_namespace": ""
      };
    } // If the file exists, verify it's not a directory


    try {
      var stat = fs.lstatSync(k8sNamespaceFileName);

      if (stat.isDirectory()) {
        _logger.logger.warn("Failed to read Kubernetes namespace information, " + "check that '/var/run/secrets/kubernetes.io/serviceaccount/namespace' is not a directory");

        return {
          "k8s_namespace": ""
        };
      }
    } catch (err) {
      _logger.logger.warn("Failed to read Kubernetes namespace information, " + "check that '/var/run/secrets/kubernetes.io/serviceaccount/namespace' status works");

      return {
        "k8s_namespace": ""
      };
    } // Read the k8s namespace from the file


    try {
      const data = fs.readFileSync(k8sNamespaceFileName, 'ascii');
      return {
        "k8s_namespace": data
      };
    } catch (err) {
      _logger.logger.warn("Failed to read Kubernetes namespace information, " + "check that '/var/run/secrets/kubernetes.io/serviceaccount/namespace' is not corrupted");
    }

    return {
      "k8s_namespace": ""
    };
  }

}

class AgentInformation extends Information {
  _getCollectors() {
    return {
      "version": () => new VersionInformation().collect(),
      "network": () => new NetworkInformation().collect(),
      "system": () => new SystemInformation().collect(),
      "platform": () => new PlatformInformation().collect(),
      "scm": () => new SCMInformation().collect(),
      "executable": () => {
        if (process.mainModule !== undefined && process.mainModule.filename !== undefined) {
          return path.basename(process.mainModule.filename);
        } else {
          return path.basename(process.argv[0]);
        }
      },
      "command_arguments": process.argv,
      "process_id": process.pid,
      "cluster": () => new ClusterInformation().collect()
    };
  }

}

let agentInfoPromise = null;

async function collect(debug, k8sNamespaceFileNameOverride = k8sNamespaceFileName_default) {
  if (!agentInfoPromise) {
    k8sNamespaceFileName = k8sNamespaceFileNameOverride;
    agentInfoPromise = new AgentInformation().collect(debug);
  }

  return agentInfoPromise;
}

function cleanupAgentInfoPromise() {
  if (agentInfoPromise) {
    agentInfoPromise = null;
  }
}

function pack_agent_info(info) {
  let packed_info = new agent_info_pb.AgentInformation();
  packed_info.setAgentId(info.agent_id);
  let version_info = new agent_info_pb.VersionInformation();
  version_info.setVersion(info.version.version);
  version_info.setCommit(info.version.commit);
  packed_info.setVersion(version_info);
  let network_info = new agent_info_pb.NetworkInformation();
  network_info.setIpAddr(info.network.ip_addr);
  network_info.setNetwork(info.network.network);
  packed_info.setNetwork(network_info);
  let system_info = new agent_info_pb.SystemInformation();
  system_info.setHostname(info.system.hostname);
  system_info.setOs(info.system.os);
  system_info.setOsVersion(info.system.os_version);
  system_info.setDistro(info.system.distro);
  system_info.setArch(info.system.arch);
  packed_info.setSystem(system_info);
  let platform_info = new agent_info_pb.PlatformInformation();
  platform_info.setPlatform(info.platform.platform);
  platform_info.setVersion(info.platform.version);
  packed_info.setPlatform(platform_info);
  let scm_info = new agent_info_pb.SCMInformation();
  scm_info.setCommit(info.scm.commit);
  scm_info.setOrigin(info.scm.origin);

  if (info.scm.origin && info.scm.commit) {
    let sourceInfo = new agent_info_pb.SCMInformation.SourceInfo();
    sourceInfo.setRemoteoriginurl(info.scm.origin);
    sourceInfo.setCommit(info.scm.commit);
    scm_info.addSources(sourceInfo);
  }

  Object.keys(info.scm.sources).forEach(origin => {
    let sourceInfo = new agent_info_pb.SCMInformation.SourceInfo();
    sourceInfo.setRemoteoriginurl(origin);
    sourceInfo.setCommit(info.scm.sources[origin]);
    scm_info.addSources(sourceInfo);
  });
  packed_info.setScm(scm_info);
  packed_info.setExecutable(info.executable);
  packed_info.setCommandArgumentsList(info.command_arguments);
  packed_info.setProcessId(info.process_id);
  let labels_map = packed_info.getLabelsMap(); // Add Kubernetes label

  if (info.cluster.k8s_namespace != "") {
    if (!info.hasOwnProperty('labels')) {
      info.labels = {
        k8s_namespace: info.cluster.k8s_namespace
      };
    } else if (info.labels["k8s_namespace"] === undefined) {
      info.labels.k8s_namespace = info.cluster.k8s_namespace;
    }
  }

  if (info.hasOwnProperty('labels')) {
    Object.keys(info.labels).forEach(key => {
      labels_map.set(key, info.labels[key]);
    });
  }

  if (info.debug) {
    labels_map.set("rookout_debug", "on");
  }

  packed_info.setTagsList(info.tags);
  return packed_info;
}
//# sourceMappingURL=information.js.map
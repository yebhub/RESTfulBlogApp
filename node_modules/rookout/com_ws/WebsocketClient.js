"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ws = _interopRequireDefault(require("ws"));

var _logger = require("../logger");

var _exceptions = require("../exceptions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const config = require("../config");

class WebsocketClient {
  constructor(url, proxy, token) {
    this.url = url;
    this.proxy = proxy;
    this.token = token;
    this._connection = null;
    this._resolve = null;
    this._reject = null;
    this._error = null;
    this._messages = [];
    this._connectTimeout = null;
    this._pingInterval = null;
    this._pingTimeout = null;
  }

  connect() {
    return new Promise((resolve, reject) => {
      this.setPromiseHandlers(resolve, reject);
      this._connection = new _ws.default(this.url, {
        headers: {
          "User-Agent": `RookoutAgent/${config.VersionConfiguration.VERSION}+${config.VersionConfiguration.COMMIT}`,
          "X-Rookout-Token": this.token
        },
        agent: this.buildProxy(),
        perMessageDeflate: false
      });
      this.setConnectTimeout();
      this.setResponseListeners();
    });
  }

  isConnected() {
    return this._connection && this._connection.readyState === _ws.default.OPEN;
  }

  read() {
    return new Promise((resolve, reject) => {
      if (this._error) {
        const error = this._error;
        this._error = null;
        reject(error);
      }

      const message = this._messages.shift();

      if (message) {
        resolve(message);
      }

      this.setPromiseHandlers(resolve, reject);
    });
  } // DON'T LOG HERE - THIS FUNCTION IS INDIRECTLY CALLED FROM WITHIN THE LOGGER
  // LOGGING HERE LEADS TO INFINITE RECURSION


  send(message) {
    return new Promise((resolve, reject) => {
      if (this._connection) {
        // For cases the callback was not called
        const timeout = setTimeout(() => {
          reject(new _exceptions.RookSendFailedError());
        }, config.AgentComConfiguration.SEND_RESOLVE_TIMEOUT).unref();

        this._connection.send(message, {
          binary: true
        }, err => {
          if (err) {
            reject(new _exceptions.RookSendFailedError());
          } else {
            resolve(); // send was successful
          }

          clearTimeout(timeout);
        });
      } else {
        reject(new _exceptions.RookNotConnectedError());
      }
    });
  }

  close() {
    if (this._connection) {
      this._connection.terminate();

      this._connection = null;
    }

    this.clearPingTimeout();
    this.clearPingInterval();
    this.clearConnectTimeout();
  }

  buildProxy() {
    if (this.proxy === null) {
      return false;
    }

    const HttpsProxyAgent = require('https-proxy-agent');

    _logger.logger.debug("Connecting via proxy: %s", this.proxy);

    if (this.proxy.startsWith("http")) {
      return HttpsProxyAgent(this.proxy);
    } else {
      return HttpsProxyAgent("http://" + this.proxy);
    }
  }

  setResponseListeners() {
    // Heartbeat runs on every ping and pong, as well as once on a new connection.
    this._connection.on("open", () => {
      try {
        _logger.logger.debug("Connection established");

        this.clearConnectTimeout(); // The socket does not exist before this point except internally - we can't access it.
        // Upon a connection timeout (currently 2 seconds), the socket will be terminated.

        if (this._connection) {
          this._connection._socket.unref();
        } // Set up pinging


        this.setPingInterval();
        this.heartbeat();
        this.returnConnected();
      } catch (e) {}
    });

    this._connection.on("ping", () => {
      try {
        this.heartbeat();
      } catch (e) {}
    });

    this._connection.on("pong", () => {
      try {
        this.heartbeat();
      } catch (e) {}
    });

    this._connection.on("close", () => {
      try {
        this.returnError('Connection closed');
      } catch (e) {}
    });

    this._connection.on("message", msg => {
      try {
        this.returnMessage(msg);
      } catch (e) {}
    }); // Connection errors (e.g. abrupt termination)


    this._connection.on("error", err => {
      try {
        this.returnError(err);
      } catch (e) {}
    }); // Unexpected HTTP responses


    this._connection.on("unexpected-response", (req, resp) => {
      try {
        this.returnError({
          statusCode: resp.statusCode
        });
      } catch (e) {}
    });
  }

  setPromiseHandlers(resolve, reject) {
    this._resolve = resolve;
    this._reject = reject;
  }

  returnConnected() {
    if (!this._resolve) {
      _logger.logger.warn("Failed to return connected status");
    }

    const resolve = this._resolve;
    this.clearPromiseHandlers();
    resolve();
  }

  returnError(error) {
    this._error = error;

    if (this._reject) {
      const reject = this._reject;
      this.clearPromiseHandlers();
      reject(error);
    }
  }

  returnMessage(message) {
    if (this._resolve) {
      const resolve = this._resolve;
      this.clearPromiseHandlers();
      resolve(message);
    } else {
      if (this._messages.length > config.AgentComConfiguration.MAX_QUEUED_MESSAGES) {
        _logger.logger.warn("Too many incoming messages, discarding");

        return;
      }

      this._messages.push(message);
    }
  }

  clearPromiseHandlers() {
    this._resolve = null;
    this._reject = null;
  }

  setConnectTimeout() {
    this.clearConnectTimeout();
    this._connectTimeout = setTimeout(() => {
      try {
        _logger.logger.error("WS connect timeout, closing connection");

        if (this._connection) {
          this._connection.terminate();

          this._connection = null;
        }
      } catch (e) {}
    }, config.AgentComConfiguration.CONNECT_TIMEOUT * 1000).unref();
  }

  clearConnectTimeout() {
    if (this._connectTimeout) {
      clearTimeout(this._connectTimeout);
      this._connectTimeout = null;
    }
  }

  resetPingTimeout() {
    this.clearPingTimeout();
    this._pingTimeout = setTimeout(() => {
      try {
        _logger.logger.error("WS ping timeout, closing connection");

        if (this._connection) {
          this._connection.terminate();

          this._connection = null;
        }
      } catch (e) {}
    }, config.AgentComConfiguration.PING_TIMEOUT * 1000).unref();
  }

  clearPingTimeout() {
    if (this._pingTimeout) {
      clearTimeout(this._pingTimeout);
      this._pingTimeout = null;
    }
  }

  setPingInterval() {
    if (this._pingInterval) {
      return;
    }

    this._pingInterval = setInterval(() => {
      try {
        if (this._connection && this._connection.readyState === _ws.default.OPEN) {
          this._connection.ping(() => {});
        }
      } catch (e) {}
    }, config.AgentComConfiguration.PING_INTERVAL * 1000).unref();
  }

  clearPingInterval() {
    if (this._pingInterval) {
      clearInterval(this._pingInterval);
      this._pingInterval = null;
    }
  }

  heartbeat() {
    this.resetPingTimeout();
  }

}

exports.default = WebsocketClient;
//# sourceMappingURL=WebsocketClient.js.map
{"version":3,"sources":["../../../src/com_ws/AgentComWs.js"],"names":["config","require","messages_pb","envelope_pb","timestamp_pb","any_pb","MessageCallback","constructor","cb","persistent","AgentComWs","id","agentHost","agentPort","proxy","token","labels","tags","debug","print_on_initial_connection","host","includes","port","_running","_callbacks","_client","_backoff","Backoff","_rejectWaitForReady","_pendingMessages","_pendingMessagesSize","_sendingPendingMessages","_lambdaKeepAliveInterval","setInterval","unref","_print_on_initial_connection","connect","connectivityLoop","then","catch","waitForReady","Promise","resolve","reject","reason","once","setTimeout","RookCommunicationException","AgentComConfiguration","TIMEOUT","on","message_name","callback","_registerCallback","messageName","hasOwnProperty","push","close","closeWebsocket","flushMessages","obj","resolveWhenReady","sendPendingMessages","add","message","envelope","wrapInEnvelope","error","validateEnvelopeForQueue","addEnvelope","length","MAX_MESSAGE_LENGTH","RookMessageSizeExceeded","isQueueFull","MAX_QUEUED_MESSAGES","MAX_QUEUED_MESSAGES_SIZE","openNewConnection","console","log","logger","_tokenValid","afterConnect","connectionPump","e","statusCode","RookInvalidToken","info","afterDisconnect","client","WebsocketClient","registerAgent","information","collect","agent_id","undefined","m","NewAgentMessage","setAgentInfo","pack_agent_info","send","read","handleIncomingMessage","isConnected","sendPendingMessagesRaw","pendingMessage","shift","Envelope","date","Timestamp","fromDate","Date","setTimestamp","any","Any","pack","serializeBinary","getTypeName","setMsg","Buffer","from","msg","deserializeBinary","typeName","getMsg","partialTypeName","slice","type","proto","com","rookout","getValue","callbacks","remaining_callbacks","forEach","err","command","k","Object","keys","ToolException","notifyLambdaInactive","notifyLambdaActive","ref"],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport {logger} from '../logger';\n\nimport * as information from \"./information\";\nimport {\n    RookCommunicationException,\n    RookInvalidToken,\n    ToolException,\n    RookMessageSizeExceeded\n} from '../exceptions'\nimport WebsocketClient from \"./WebsocketClient\";\nimport Backoff from \"./backoff\";\n\nconst config = require(\"../config\");\nconst messages_pb = require(\"../protobuf/messages_pb\");\nconst envelope_pb = require(\"../protobuf/envelope_pb\");\nconst timestamp_pb = require(\"google-protobuf/google/protobuf/timestamp_pb\");\nconst any_pb = require(\"google-protobuf/google/protobuf/any_pb\");\n\nclass MessageCallback {\n    constructor(cb, persistent) {\n        this.cb = cb;\n        this.persistent = persistent;\n    }\n}\n\nexport default class AgentComWs {\n\n    constructor(id, agentHost, agentPort, proxy = null, token = null, labels = null, tags = null,\n                debug = false, print_on_initial_connection = false) {\n        this.id = id;\n        this.host = agentHost.includes('://') ? agentHost : 'ws://' + agentHost;\n        this.port = agentPort;\n        this.proxy = proxy;\n        this.labels = labels || {};\n        this.tags = tags || [];\n        this.token = token || '';\n        this.debug = debug;\n\n        this._running = false;\n        this._callbacks = {};\n        this._client = null;\n        this._backoff = new Backoff();\n\n        this._rejectWaitForReady = null;\n\n        // TODO - This can be separated into a different class\n        this._pendingMessages = [];\n        this._pendingMessagesSize = 0;\n        this._sendingPendingMessages = false;\n\n        // TODO - think if this belongs here (hint - no!)\n        // Used to keep lambdas alive before we're finished.\n        // Normally you would use the socket, but we might want to keep running when the socket doesn't exist\n        // (e.g. after disconnection followed by a flush at the end of lambda execution)\n        this._lambdaKeepAliveInterval = setInterval(() => {\n            if (1) {\n            }\n        }, 60000).unref();\n\n        this._print_on_initial_connection = print_on_initial_connection;\n    }\n\n    connect() {\n        this._running = true;\n\n        this.connectivityLoop().then(() => {}).catch(() => {});\n    }\n\n    waitForReady() {\n        /**\n         * Returns a promise, that is resolved once the connection\n         * with the controller is ready, or rejected after a\n         * configured timeout.\n         */\n        return new Promise((resolve, reject) => {\n            this._rejectWaitForReady = (reason) => {\n                this._rejectWaitForReady = null;\n                reject(reason);\n            }\n\n            this.once(\"InitialAugsCommand\", () => {\n                this._rejectWaitForReady = null;\n                resolve();\n            });\n\n            setTimeout(() => {\n                    this._rejectWaitForReady = null;\n                    reject(new RookCommunicationException)\n                },\n                config.AgentComConfiguration.TIMEOUT * 1000);\n        });\n    }\n\n    on(message_name, callback) {\n        this._registerCallback(message_name, new MessageCallback(callback, true))\n    }\n\n    once(message_name, callback) {\n        this._registerCallback(message_name, new MessageCallback(callback, false))\n    }\n\n    _registerCallback(messageName, callback) {\n        if (!(this._callbacks.hasOwnProperty(messageName))) {\n            this._callbacks[messageName] = [];\n        }\n        this._callbacks[messageName].push(callback);\n    }\n\n    close() {\n        this._running = false;\n\n        this.closeWebsocket();\n    }\n\n    closeWebsocket() {\n        if (this._client) {\n            this._client.close();\n            this._client = null;\n        }\n    }\n\n    flushMessages() {\n        // Returns a promise that is resolved once all messages up to this point have been sent or failed to send.\n\n        return new Promise((resolve) => {\n            let obj = {resolveWhenReady: resolve};\n            this._pendingMessages.push(obj);\n            this.sendPendingMessages();\n        });\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // DON'T LOG HERE - THESE FUNCTIONS ARE INDIRECTLY CALLED FROM WITHIN THE LOGGER\n    // LOGGING HERE LEADS TO INFINITE RECURSION\n    add(message) {\n        // gets a message, wraps it in envelope, validates it and pushes it to queue.\n        // if the validation has not passed the validation status is returned before pushing to the queue.\n\n        const envelope = AgentComWs.wrapInEnvelope(message);\n\n        const error = this.validateEnvelopeForQueue(envelope);\n        if (error) {\n            return error;\n        }\n\n        this.addEnvelope(envelope)\n        this.sendPendingMessages();\n    }\n\n    validateEnvelopeForQueue(envelope) {\n        // Validates the given envelope by the queue standards and return an error if it doesn't meet them\n        if (envelope.length > config.AgentComConfiguration.MAX_MESSAGE_LENGTH) {\n            return new RookMessageSizeExceeded(envelope.length, config.AgentComConfiguration.MAX_MESSAGE_LENGTH);\n        }\n\n        return null;\n    }\n\n    addEnvelope(envelope) {\n        if (this.isQueueFull()) {\n            return;\n        }\n\n        this._pendingMessages.push(envelope);\n        this._pendingMessagesSize += envelope.length;\n    }\n\n    isQueueFull() {\n        if (this._pendingMessages.length >= config.AgentComConfiguration.MAX_QUEUED_MESSAGES) {\n            return true;\n        }\n\n        if (this._pendingMessagesSize >= config.AgentComConfiguration.MAX_QUEUED_MESSAGES_SIZE) {\n            return true;\n        }\n\n        return false;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    async connectivityLoop() {\n        while (this._running) {\n            try {\n                await this.openNewConnection()\n\n                if (this._print_on_initial_connection) {\n                    /* So that there is no print on re-connect */\n                    this._print_on_initial_connection = false\n                    console.log(\"[Rookout] Successfully connected to controller.\")\n                }\n                logger.debug(`WebSocket connected successfully`);\n\n                this._tokenValid = true;\n                this._backoff.afterConnect();\n\n                await this.connectionPump()\n            } catch (e) {\n                if (e.statusCode === 403 && !this._tokenValid && this._rejectWaitForReady) {\n                    this._rejectWaitForReady(new RookInvalidToken(this.token));\n                }\n\n                logger.info(`Connection failed; reason = ${e}`);\n            }\n\n            await this._backoff.afterDisconnect();\n            logger.debug(`Reconnecting`);\n        }\n    }\n\n    async openNewConnection() {\n        this.closeWebsocket();\n\n        const client = new WebsocketClient(`${this.host}:${this.port}/v1`, this.proxy, this.token);\n        try {\n            await client.connect();\n\n            logger.info(`Registering agent with id ${this.id}`)\n            await this.registerAgent(client);\n        } catch (e) {\n            client.close();\n            throw e;\n        }\n\n        this._client = client;\n    }\n\n    async registerAgent(client) {\n        let info = await information.collect(this.debug);\n        info.agent_id = this.id;\n        info.labels = this.labels;\n        if (this.tags !== undefined) {\n            info.tags = this.tags;\n        }\n\n        let m = new messages_pb.NewAgentMessage();\n        m.setAgentInfo(information.pack_agent_info(info));\n\n        await client.send(AgentComWs.wrapInEnvelope(m));\n\n        logger.info(\"Finished initialization\");\n    }\n\n    async connectionPump() {\n        this.sendPendingMessages();\n\n        while (this._running) {\n            const message = await this._client.read();\n            this.handleIncomingMessage(message);\n        }\n    }\n\n    sendPendingMessages() {\n        // Spare creating the promise if not needed\n        if (this._sendingPendingMessages || !this._client || !this._client.isConnected()) {\n            return;\n        }\n\n        this.sendPendingMessagesRaw().then(() => {}).catch(() => {});\n    }\n\n    async sendPendingMessagesRaw() {\n        // We allow only one sending loop at any given time, and only if the socket is connected\n        if (this._sendingPendingMessages || !this._client || !this._client.isConnected()) {\n            return;\n        }\n\n        this._sendingPendingMessages = true;\n\n        try {\n            // Sends all messages in queue until it's empty, if send function returns an error the function stops and pushes the message into the queue.\n            while (this._running && this._pendingMessages.length > 0) {\n                let pendingMessage = this._pendingMessages.shift();\n                if (pendingMessage === undefined) {\n                    break;\n                }\n\n                if (pendingMessage.resolveWhenReady !== undefined) {\n                    pendingMessage.resolveWhenReady();\n                    continue;\n                }\n\n                this._pendingMessagesSize -= pendingMessage.length;\n                try {\n                    await this._client.send(pendingMessage);\n                } catch (e) {\n                    // TODO - someday, push to the beginning of the queue instead of the end\n                    this.addEnvelope(pendingMessage);\n                    return;\n                }\n            }\n        } finally {\n            this._sendingPendingMessages = false;\n        }\n    }\n\n    static wrapInEnvelope(message) {\n        const envelope = new envelope_pb.Envelope();\n        const date = new timestamp_pb.Timestamp();\n        date.fromDate(new Date());\n        envelope.setTimestamp(date);\n        const any = new any_pb.Any();\n        any.pack(message.serializeBinary(), AgentComWs.getTypeName(message));\n        envelope.setMsg(any);\n        return Buffer.from(envelope.serializeBinary());\n    }\n\n    handleIncomingMessage(msg) {\n        let envelope = envelope_pb.Envelope.deserializeBinary(msg);\n        let typeName = envelope.getMsg().getTypeName();\n\n        const partialTypeName = typeName.slice(\"com.rookout.\".length);\n        let type = proto.com.rookout[partialTypeName];\n        let message = type.deserializeBinary(envelope.getMsg().getValue());\n\n        const callbacks = this._callbacks[partialTypeName];\n\n        if (callbacks !== undefined) {\n            let remaining_callbacks = [];\n\n            callbacks.forEach((callback) => {\n                try {\n                    callback.cb(message)\n                } catch (err) {\n                    logger.debug(`Silenced error from callback: ${err}`)\n                } finally {\n                    if (callback.persistent) {\n                        remaining_callbacks.push(callback)\n                    }\n                }\n\n            });\n            this._callbacks[partialTypeName] = remaining_callbacks;\n        }\n    }\n\n    static getTypeName(command) {\n        for (let k of Object.keys(proto.com.rookout)) {\n            if (proto.com.rookout[k] === command.constructor) {\n                return \"com.rookout.\" + k;\n            }\n        }\n\n        throw new ToolException();\n    }\n\n    notifyLambdaInactive() {\n        this._lambdaKeepAliveInterval.unref();\n    }\n\n    notifyLambdaActive() {\n        this._lambdaKeepAliveInterval.ref();\n    }\n}\n"],"file":"AgentComWs.js"}
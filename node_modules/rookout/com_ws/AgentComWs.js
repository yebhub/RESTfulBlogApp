"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logger = require("../logger");

var information = _interopRequireWildcard(require("./information"));

var _exceptions = require("../exceptions");

var _WebsocketClient = _interopRequireDefault(require("./WebsocketClient"));

var _backoff = _interopRequireDefault(require("./backoff"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const config = require("../config");

const messages_pb = require("../protobuf/messages_pb");

const envelope_pb = require("../protobuf/envelope_pb");

const timestamp_pb = require("google-protobuf/google/protobuf/timestamp_pb");

const any_pb = require("google-protobuf/google/protobuf/any_pb");

class MessageCallback {
  constructor(cb, persistent) {
    this.cb = cb;
    this.persistent = persistent;
  }

}

class AgentComWs {
  constructor(id, agentHost, agentPort, proxy = null, token = null, labels = null, tags = null, debug = false, print_on_initial_connection = false) {
    this.id = id;
    this.host = agentHost.includes('://') ? agentHost : 'ws://' + agentHost;
    this.port = agentPort;
    this.proxy = proxy;
    this.labels = labels || {};
    this.tags = tags || [];
    this.token = token || '';
    this.debug = debug;
    this._running = false;
    this._callbacks = {};
    this._client = null;
    this._backoff = new _backoff.default();
    this._rejectWaitForReady = null; // TODO - This can be separated into a different class

    this._pendingMessages = [];
    this._pendingMessagesSize = 0;
    this._sendingPendingMessages = false; // TODO - think if this belongs here (hint - no!)
    // Used to keep lambdas alive before we're finished.
    // Normally you would use the socket, but we might want to keep running when the socket doesn't exist
    // (e.g. after disconnection followed by a flush at the end of lambda execution)

    this._lambdaKeepAliveInterval = setInterval(() => {
      if (1) {}
    }, 60000).unref();
    this._print_on_initial_connection = print_on_initial_connection;
  }

  connect() {
    this._running = true;
    this.connectivityLoop().then(() => {}).catch(() => {});
  }

  waitForReady() {
    /**
     * Returns a promise, that is resolved once the connection
     * with the controller is ready, or rejected after a
     * configured timeout.
     */
    return new Promise((resolve, reject) => {
      this._rejectWaitForReady = reason => {
        this._rejectWaitForReady = null;
        reject(reason);
      };

      this.once("InitialAugsCommand", () => {
        this._rejectWaitForReady = null;
        resolve();
      });
      setTimeout(() => {
        this._rejectWaitForReady = null;
        reject(new _exceptions.RookCommunicationException());
      }, config.AgentComConfiguration.TIMEOUT * 1000);
    });
  }

  on(message_name, callback) {
    this._registerCallback(message_name, new MessageCallback(callback, true));
  }

  once(message_name, callback) {
    this._registerCallback(message_name, new MessageCallback(callback, false));
  }

  _registerCallback(messageName, callback) {
    if (!this._callbacks.hasOwnProperty(messageName)) {
      this._callbacks[messageName] = [];
    }

    this._callbacks[messageName].push(callback);
  }

  close() {
    this._running = false;
    this.closeWebsocket();
  }

  closeWebsocket() {
    if (this._client) {
      this._client.close();

      this._client = null;
    }
  }

  flushMessages() {
    // Returns a promise that is resolved once all messages up to this point have been sent or failed to send.
    return new Promise(resolve => {
      let obj = {
        resolveWhenReady: resolve
      };

      this._pendingMessages.push(obj);

      this.sendPendingMessages();
    });
  } ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // DON'T LOG HERE - THESE FUNCTIONS ARE INDIRECTLY CALLED FROM WITHIN THE LOGGER
  // LOGGING HERE LEADS TO INFINITE RECURSION


  add(message) {
    // gets a message, wraps it in envelope, validates it and pushes it to queue.
    // if the validation has not passed the validation status is returned before pushing to the queue.
    const envelope = AgentComWs.wrapInEnvelope(message);
    const error = this.validateEnvelopeForQueue(envelope);

    if (error) {
      return error;
    }

    this.addEnvelope(envelope);
    this.sendPendingMessages();
  }

  validateEnvelopeForQueue(envelope) {
    // Validates the given envelope by the queue standards and return an error if it doesn't meet them
    if (envelope.length > config.AgentComConfiguration.MAX_MESSAGE_LENGTH) {
      return new _exceptions.RookMessageSizeExceeded(envelope.length, config.AgentComConfiguration.MAX_MESSAGE_LENGTH);
    }

    return null;
  }

  addEnvelope(envelope) {
    if (this.isQueueFull()) {
      return;
    }

    this._pendingMessages.push(envelope);

    this._pendingMessagesSize += envelope.length;
  }

  isQueueFull() {
    if (this._pendingMessages.length >= config.AgentComConfiguration.MAX_QUEUED_MESSAGES) {
      return true;
    }

    if (this._pendingMessagesSize >= config.AgentComConfiguration.MAX_QUEUED_MESSAGES_SIZE) {
      return true;
    }

    return false;
  } ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


  async connectivityLoop() {
    while (this._running) {
      try {
        await this.openNewConnection();

        if (this._print_on_initial_connection) {
          /* So that there is no print on re-connect */
          this._print_on_initial_connection = false;
          console.log("[Rookout] Successfully connected to controller.");
        }

        _logger.logger.debug(`WebSocket connected successfully`);

        this._tokenValid = true;

        this._backoff.afterConnect();

        await this.connectionPump();
      } catch (e) {
        if (e.statusCode === 403 && !this._tokenValid && this._rejectWaitForReady) {
          this._rejectWaitForReady(new _exceptions.RookInvalidToken(this.token));
        }

        _logger.logger.info(`Connection failed; reason = ${e}`);
      }

      await this._backoff.afterDisconnect();

      _logger.logger.debug(`Reconnecting`);
    }
  }

  async openNewConnection() {
    this.closeWebsocket();
    const client = new _WebsocketClient.default(`${this.host}:${this.port}/v1`, this.proxy, this.token);

    try {
      await client.connect();

      _logger.logger.info(`Registering agent with id ${this.id}`);

      await this.registerAgent(client);
    } catch (e) {
      client.close();
      throw e;
    }

    this._client = client;
  }

  async registerAgent(client) {
    let info = await information.collect(this.debug);
    info.agent_id = this.id;
    info.labels = this.labels;

    if (this.tags !== undefined) {
      info.tags = this.tags;
    }

    let m = new messages_pb.NewAgentMessage();
    m.setAgentInfo(information.pack_agent_info(info));
    await client.send(AgentComWs.wrapInEnvelope(m));

    _logger.logger.info("Finished initialization");
  }

  async connectionPump() {
    this.sendPendingMessages();

    while (this._running) {
      const message = await this._client.read();
      this.handleIncomingMessage(message);
    }
  }

  sendPendingMessages() {
    // Spare creating the promise if not needed
    if (this._sendingPendingMessages || !this._client || !this._client.isConnected()) {
      return;
    }

    this.sendPendingMessagesRaw().then(() => {}).catch(() => {});
  }

  async sendPendingMessagesRaw() {
    // We allow only one sending loop at any given time, and only if the socket is connected
    if (this._sendingPendingMessages || !this._client || !this._client.isConnected()) {
      return;
    }

    this._sendingPendingMessages = true;

    try {
      // Sends all messages in queue until it's empty, if send function returns an error the function stops and pushes the message into the queue.
      while (this._running && this._pendingMessages.length > 0) {
        let pendingMessage = this._pendingMessages.shift();

        if (pendingMessage === undefined) {
          break;
        }

        if (pendingMessage.resolveWhenReady !== undefined) {
          pendingMessage.resolveWhenReady();
          continue;
        }

        this._pendingMessagesSize -= pendingMessage.length;

        try {
          await this._client.send(pendingMessage);
        } catch (e) {
          // TODO - someday, push to the beginning of the queue instead of the end
          this.addEnvelope(pendingMessage);
          return;
        }
      }
    } finally {
      this._sendingPendingMessages = false;
    }
  }

  static wrapInEnvelope(message) {
    const envelope = new envelope_pb.Envelope();
    const date = new timestamp_pb.Timestamp();
    date.fromDate(new Date());
    envelope.setTimestamp(date);
    const any = new any_pb.Any();
    any.pack(message.serializeBinary(), AgentComWs.getTypeName(message));
    envelope.setMsg(any);
    return Buffer.from(envelope.serializeBinary());
  }

  handleIncomingMessage(msg) {
    let envelope = envelope_pb.Envelope.deserializeBinary(msg);
    let typeName = envelope.getMsg().getTypeName();
    const partialTypeName = typeName.slice("com.rookout.".length);
    let type = proto.com.rookout[partialTypeName];
    let message = type.deserializeBinary(envelope.getMsg().getValue());
    const callbacks = this._callbacks[partialTypeName];

    if (callbacks !== undefined) {
      let remaining_callbacks = [];
      callbacks.forEach(callback => {
        try {
          callback.cb(message);
        } catch (err) {
          _logger.logger.debug(`Silenced error from callback: ${err}`);
        } finally {
          if (callback.persistent) {
            remaining_callbacks.push(callback);
          }
        }
      });
      this._callbacks[partialTypeName] = remaining_callbacks;
    }
  }

  static getTypeName(command) {
    for (let k of Object.keys(proto.com.rookout)) {
      if (proto.com.rookout[k] === command.constructor) {
        return "com.rookout." + k;
      }
    }

    throw new _exceptions.ToolException();
  }

  notifyLambdaInactive() {
    this._lambdaKeepAliveInterval.unref();
  }

  notifyLambdaActive() {
    this._lambdaKeepAliveInterval.ref();
  }

}

exports.default = AgentComWs;
//# sourceMappingURL=AgentComWs.js.map
{"version":3,"sources":["../../../src/services/ScriptWrapper.js"],"names":["fs","require","path","CryptoJS","SHA256","ScriptWrapper","constructor","id","filename","source","sourceFiles","normalizedFilename","fileHash","_generateSourceHash","mapConsumer","loadMap","mapData","readFileSync","e","logger","debug","message","map","mapObject","SourceMapConsumer","sourceFile","sources","sourceContentFor","push","normalizedPath","rawPath","linesCrc32s","_generateLinesCrc32sFromSource","getMatchInfo","notification","isAbsolute","includes","includeExternals","fileSource","error","updatedLineNumber","generatedPosition","lineno","column","arePathsConverging","sourceFilePath","join","dirname","adjacentSourceFile","basename","existsSync","getRawFileContents","userWarnings","sendWarning","RookError","RookSourceMissing","getUpdateLineNumber","getGeneratedPosition","line","script","getMatchedFilename","FilenameBase","undefined","path1","path2","i","length","j","sep","lineCrc32","lineUnique","updateLineUsingCrc","testFileHash","firstIndex","indexOf","lastIndex","lastIndexOf","updatedLine","RookLineMoved","RookCrcMismatchException","RookHashMismatchException","position","generatedPositionFor","bias","LEAST_UPPER_BOUND","warn","RookResolveSourceFailed","getOriginalPosition","originalPositionFor","RookSourceError","replace","lines","split","toString","enc","Hex"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nimport {logger} from \"../logger\";\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst CryptoJS = require('crypto-js');\r\nconst SHA256 = require('crypto-js/sha256');\r\n\r\nimport {resolveSourceMapSync} from 'source-map-resolve';\r\nimport {SourceMapConsumer} from 'source-map';\r\nimport {normalize} from \"./source-map-util\"\r\nimport crc32 from \"crc/lib/es6/crc32\";\r\n\r\nimport {canonizeFileName} from \"../utils\";\r\nimport {\r\n    RookCrcMismatchException,\r\n    RookHashMismatchException,\r\n    RookLineMoved,\r\n    RookResolveSourceFailed,\r\n    RookSourceError,\r\n    RookSourceMissing\r\n} from '../exceptions'\r\nimport RookError from \"../processor/RookError\";\r\n\r\nexport default class ScriptWrapper {\r\n\r\n    constructor(id, filename, source) {\r\n        this.id = id;\r\n\r\n        this.sourceFiles = [];\r\n\r\n        this.filename = filename;\r\n        this.normalizedFilename = canonizeFileName(filename);\r\n\r\n        this.fileHash = this._generateSourceHash(source);\r\n\r\n        this.mapConsumer = null;\r\n\r\n        this.loadMap(source);\r\n    }\r\n\r\n    loadMap(source) {\r\n        if (!this.filename || !source) {\r\n            return;\r\n        }\r\n\r\n        let mapData = null;\r\n\r\n        try {\r\n            mapData = resolveSourceMapSync(source, this.filename, fs.readFileSync);\r\n        } catch (e) {\r\n            logger.debug(\"Unable to find source map\", this.filename, e.message);\r\n        }\r\n\r\n        if (!mapData || !mapData.map) {\r\n            return;\r\n        }\r\n\r\n        const mapObject = mapData.map;\r\n        this.mapConsumer = new SourceMapConsumer(mapObject);\r\n\r\n        for (let sourceFile of mapObject.sources) {\r\n            let source = this.mapConsumer.sourceContentFor(sourceFile, true);\r\n            this.sourceFiles.push({\r\n                normalizedPath : canonizeFileName(sourceFile),\r\n                rawPath: sourceFile,\r\n                fileHash: this._generateSourceHash(source),\r\n                linesCrc32s: this._generateLinesCrc32sFromSource(source)\r\n            });\r\n        }\r\n    }\r\n\r\n    getMatchInfo(notification) {\r\n        // Exclude NodeJS core libs\r\n        if (!path.isAbsolute(this.filename)) {\r\n            return null;\r\n        }\r\n\r\n        if (this.filename.includes('/node_modules/') && !notification.includeExternals) {\r\n            return null;\r\n        }\r\n\r\n        let fileSource = null;\r\n        let fileHash = null;\r\n        let linesCrc32s = null;\r\n        let error = null;\r\n        let updatedLineNumber = null;\r\n        let generatedPosition = null;\r\n        let lineno = null;\r\n        let column = null;\r\n\r\n        for (let sourceFile of this.sourceFiles) {\r\n            if (this.arePathsConverging(sourceFile.normalizedPath, notification.filename)) {\r\n                // If we are dealing with a transpiled file, we prefer getting the source from disk\r\n                // Otherwise, we have to stick with the source map, even if it's of lower accuracy\r\n\r\n                const sourceFilePath = path.join(path.dirname(this.filename), sourceFile.normalizedPath);\r\n                const adjacentSourceFile = path.join(path.dirname(this.filename), path.basename(sourceFile.normalizedPath));\r\n\r\n                if (fs.existsSync(sourceFilePath)) {\r\n                    fileSource = this.getRawFileContents(sourceFilePath);\r\n                    fileHash = this._generateSourceHash(fileSource);\r\n                    linesCrc32s = this._generateLinesCrc32sFromSource(fileSource);\r\n                } else if (adjacentSourceFile !== this.filename &&\r\n                        fs.existsSync(adjacentSourceFile)) {\r\n                    fileSource = this.getRawFileContents(adjacentSourceFile);\r\n                    fileHash = this._generateSourceHash(fileSource);\r\n                    linesCrc32s = this._generateLinesCrc32sFromSource(fileSource);\r\n                } else {\r\n                    fileHash = sourceFile.fileHash;\r\n                    linesCrc32s = sourceFile.linesCrc32s;\r\n                }\r\n\r\n                try {\r\n                    if (fileHash === null || linesCrc32s === null) {\r\n                        notification.userWarnings.sendWarning(new RookError(new RookSourceMissing(notification.filename)));\r\n                        updatedLineNumber = notification.lineno;\r\n                    } else {\r\n                        updatedLineNumber = this.getUpdateLineNumber(notification, fileHash, linesCrc32s);\r\n                    }\r\n\r\n                    generatedPosition = this.getGeneratedPosition(normalize(sourceFile.rawPath), updatedLineNumber, notification.column);\r\n                    lineno = generatedPosition.line;\r\n                    column = generatedPosition.column;\r\n                } catch (e) {\r\n                    // Those exceptions will be handled in LocationFileLine, should be handled here\r\n                    lineno = null;\r\n                    error = e;\r\n                }\r\n\r\n                return {\r\n                    script: this,\r\n                    lineno: lineno,\r\n                    column: column,\r\n                    error: error\r\n                };\r\n            }\r\n        }\r\n\r\n        if (this.arePathsConverging(this.normalizedFilename, notification.filename)) {\r\n            fileSource = this.getRawFileContents(this.filename);\r\n            fileHash = this._generateSourceHash(fileSource);\r\n            linesCrc32s = this._generateLinesCrc32sFromSource(fileSource);\r\n\r\n            try {\r\n                updatedLineNumber = this.getUpdateLineNumber(notification, fileHash, linesCrc32s);\r\n            } catch (e) {\r\n                error = e;\r\n            }\r\n\r\n            return {\r\n                script: this,\r\n                lineno: updatedLineNumber,\r\n                column : notification.column,\r\n                error: error\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    getMatchedFilename(FilenameBase, fileHash) {\r\n        try {\r\n            if (this.sourceFiles === null || this.sourceFiles === undefined) {\r\n                return null;\r\n            }\r\n\r\n            for (const sourceFile of this.sourceFiles) {\r\n                if (FilenameBase === path.basename(sourceFile.normalizedPath)\r\n                    && sourceFile.fileHash === fileHash) {\r\n                    return sourceFile.normalizedPath;\r\n                }\r\n            }\r\n\r\n            if (FilenameBase === path.basename(this.filename) && this.fileHash === fileHash) {\r\n                return this.filename;\r\n            }\r\n\r\n            return null;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    arePathsConverging(path1, path2) {\r\n        // Find longest match\r\n        let i = path1.length - 1;\r\n        let j = path2.length - 1;\r\n        while (i >= 0 && j >= 0 && path1[i] === path2[j]) {\r\n            --i;\r\n            --j;\r\n        }\r\n\r\n        // Check that at least one of the strings has ended and the other is at a directory boundary\r\n        return (i === -1 && path2[j] === path.sep) || (j === -1 && path1[i] === path.sep) || (i === -1 && j === -1);\r\n    }\r\n\r\n    getUpdateLineNumber(notification, fileHash, linesCrc32s) {\r\n        if (null != notification.lineCrc32 && null != notification.lineUnique) {\r\n            return this.updateLineUsingCrc(notification, fileHash, linesCrc32s);\r\n        }\r\n\r\n        if (null != fileHash && null != notification.fileHash) {\r\n            this.testFileHash(notification, fileHash)\r\n            return notification.lineno;\r\n        }\r\n\r\n        return notification.lineno;\r\n    }\r\n\r\n    updateLineUsingCrc(notification, fileHash, linesCrc32s) {\r\n        // If the line has not changed, we are good - return\r\n        let lineCrc32;\r\n        if (linesCrc32s.length >= notification.lineno) {\r\n            lineCrc32 = linesCrc32s[notification.lineno - 1];\r\n        }\r\n        if (lineCrc32 === notification.lineCrc32) {\r\n            return notification.lineno;\r\n        }\r\n\r\n        // If the line was unique in the original file, let's try to find it in this file\r\n        if (notification.lineUnique === true) {\r\n            // If the line was unique in the original file and is still original here - send a warning and return\r\n            const firstIndex = linesCrc32s.indexOf(notification.lineCrc32);\r\n            const lastIndex = linesCrc32s.lastIndexOf(notification.lineCrc32);\r\n\r\n            if ((firstIndex !== -1) && (firstIndex === lastIndex)) {\r\n                const updatedLine = firstIndex + 1;\r\n                notification.userWarnings.sendWarning(new RookError(new RookLineMoved(notification.filename, notification.lineno, updatedLine)));\r\n                return updatedLine;\r\n            }\r\n        }\r\n\r\n        // We failed to get a good match - throw an error\r\n        throw new RookCrcMismatchException(notification.filename, notification.lineCrc32, lineCrc32);\r\n    }\r\n\r\n    testFileHash(notification, fileHash) {\r\n        if (fileHash !== notification.fileHash) {\r\n            throw new RookHashMismatchException(notification.filename, notification.fileHash, fileHash);\r\n        }\r\n    }\r\n\r\n    getGeneratedPosition(filename, line, column) {\r\n        const position = this.mapConsumer.generatedPositionFor({\r\n            source: filename,\r\n            line: line,\r\n            column: column,\r\n            bias: SourceMapConsumer.LEAST_UPPER_BOUND});\r\n\r\n        if (null === position.column) {\r\n            logger.warn(\"Got NULL column from source-map!\")\r\n        }\r\n\r\n        // generatedPositionFor might return zeroed position instance upon failure and not null\r\n        if (position !== null && position.line !== null) {\r\n            return position;\r\n        } else {\r\n            throw new RookResolveSourceFailed(this.filename);\r\n        }\r\n    }\r\n\r\n    getOriginalPosition(line, column) {\r\n        return this.mapConsumer.originalPositionFor({line: line, column: column});\r\n    }\r\n\r\n    getRawFileContents(filename) {\r\n        try {\r\n            return fs.readFileSync(filename, 'utf8');\r\n        } catch (e) {\r\n            throw new RookSourceError(this.filename, e);\r\n        }\r\n    }\r\n\r\n    _generateLinesCrc32sFromSource(source) {\r\n        if (source === null) {\r\n            return source;\r\n        }\r\n\r\n        source = source.replace(/(?:\\r\\n|\\r|\\n)/g, \"\\n\");\r\n        const lines = source.split(\"\\n\");\r\n        return lines.map(line => crc32(line).toString(16));\r\n    }\r\n\r\n    _generateSourceHash(source) {\r\n        if (source === null) {\r\n            return source;\r\n        }\r\n\r\n        source = source.replace(/(?:\\r\\n|\\r|\\n)/g, \"\\n\");\r\n        return SHA256(source).toString(CryptoJS.enc.Hex);\r\n    }\r\n}\r\n"],"file":"ScriptWrapper.js"}
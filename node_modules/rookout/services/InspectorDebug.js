"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InspectorDebug = void 0;

var _logger = require("../logger");

var _exceptions = require("../exceptions");

var _IgnoredNodeModules = require("./IgnoredNodeModules");

var _InspectorFrameNamespace = _interopRequireDefault(require("../processor/namespaces/InspectorFrameNamespace"));

var _InspectorStackNamespace = _interopRequireDefault(require("../processor/namespaces/InspectorStackNamespace"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inspector = require('inspector');

const url = require('url');

const path = require("path");

const LRU = require("lru-cache");

const config = require("../config");

class InspectorDebug {
  constructor(userLine, scriptLoaded, getScript, dbgService) {
    if (InspectorDebug.isElectron()) {
      InspectorDebug.verifyInspectFlagEnabledUnderElectron();
    } else {
      // Setting the --inspect CLI flag means the inspector will be active, so we can't
      // run this verification in that case.
      InspectorDebug.verifyNoDebuggerConnected();
    }

    this.getScriptCallback = getScript;
    this.userLine = userLine;
    this.scriptLoaded = scriptLoaded;
    this.dbgService = dbgService;
    this.positionsToBreakpoints = {};
    this.breakpointsToPositions = {};
    this.loadedScriptsCount = 0;
    this.loadedScriptsSize = 0;
    this.cache = new LRU({
      max: 2500
    });
    this.paused = false;
    this.startSession();
  }

  async startSession() {
    this.session = new inspector.Session();

    try {
      this.session.connect();
    } catch (e) {
      throw new _exceptions.RookInspectorConnectFailed(e);
    }

    this.session.on('Debugger.scriptParsed', ({
      params
    }) => {
      if (this.session === null || !this.dbgService || this.dbgService.permanently_closed) {
        return;
      }

      try {
        let scriptURL = params.url; // URLs instead of paths started in 10.12 which also introduced this
        // url.fileURLToPath. We assume we will not receive URLs before 10.12

        if (scriptURL.startsWith("file:") && url.fileURLToPath !== undefined) {
          scriptURL = url.fileURLToPath(scriptURL);
        }

        let shouldSkipScript = false;
        let shouldCountScript = true;

        if (scriptURL === "" || (0, _IgnoredNodeModules.isBlackListedModule)(scriptURL)) {
          if (this.validate_version(12, 5)) {
            shouldCountScript = false;
          }

          shouldSkipScript = true;
        }

        if (shouldCountScript) {
          this.loadedScriptsCount++;

          if (!this.validate_version(12, 5)) {
            this.loadedScriptsSize += params.length;
          }
        }

        if (this.loadedScriptsCount > config.InstrumentationConfig.MAX_SCRIPTS_COUNT_FAIL_SAFE || this.loadedScriptsSize > config.InstrumentationConfig.MAX_SCRIPTS_SIZE_FAIL_SAFE) {
          _logger.logger.warn(`An unsafe number of scripts loaded - stopping agent, ${this.loadedScriptsCount} were loaded, with size of ${this.loadedScriptsSize} bytes. The last script we got was ${params.url}`);

          this.dbgService.close(true).then(() => _logger.logger.warn('Closed the debugger')).catch(() => _logger.logger.error("Failed to close debugger"));
          return;
        }

        if (shouldSkipScript) {
          return;
        }

        this.post('Debugger.getScriptSource', {
          scriptId: params.scriptId
        }, (err, scriptSource) => {
          if (err) {
            _logger.logger.exception("Failed to get script source", err);

            return;
          }

          try {
            this.scriptLoaded(params.scriptId, scriptURL, scriptSource.scriptSource);
          } catch (error) {
            _logger.logger.exception("Exception when processing script source callback", error);
          }
        });
      } catch (error) {
        _logger.logger.exception("Exception when processing script parse callback", error);
      } finally {
        if (!this.paused) {
          this.post("Runtime.releaseObjectGroup", {
            objectGroup: "backtrace"
          });
        }
      }
    });
    this.session.on('Debugger.scriptFailedToParse', ({
      params
    }) => {
      if (this.paused || this.session === null || !this.dbgService || this.dbgService.permanently_closed) {
        return;
      }

      this.post("Runtime.releaseObjectGroup", {
        objectGroup: "backtrace"
      });
    });
    this.session.on('Debugger.paused', message => {
      if (this.session === null) {
        return;
      }

      try {
        this.paused = true;
        const pos = this.breakpointsToPositions[message.params.hitBreakpoints[0]];

        if (!pos) {
          _logger.logger.error(`Aug not found! ${JSON.stringify(message.params)}`);
        } else {
          this.userLine(pos, new _InspectorStackNamespace.default(this, message.params.callFrames));
        }
      } catch (error) {
        _logger.logger.exception(error);
      } finally {
        this.paused = false;
        this.post("Debugger.resume");
      }
    });
    this.session.on('error', error => {
      try {
        _logger.logger.exception('InspectorDebugger error', error);
      } catch (e) {}
    });

    if (this.validate_version(12, 9)) {
      // Not allowing the debugger to collect scripts, only available in 12.9.0V
      await this.async_post('Debugger.enable', {
        maxScriptsCacheSize: 2
      });
    } else {
      await this.async_post('Debugger.enable');
    }

    await this.async_post('Debugger.setAsyncCallStackDepth', {
      maxDepth: 1
    });
    await this.async_post('Debugger.setBreakpointsActive', {
      active: true
    });

    if (this.validate_version(14)) {
      this.cleanupAsyncCallStackInterval = setInterval(() => {
        try {
          this.post('Debugger.setAsyncCallStackDepth', {
            maxDepth: 0
          });
          this.post('Debugger.setAsyncCallStackDepth', {
            maxDepth: 1
          });
        } catch (err) {
          _logger.logger.debug(`cleanupAsyncCallStack error: ${err}`);
        }
      }, config.InstrumentationConfig.CLEANUP_ASYNC_CALLSTACK_INTERVAL_MILLISECONDS).unref();
    }
  }

  clearCleanupAsyncCallStackInterval() {
    if (this.cleanupAsyncCallStackInterval) {
      clearInterval(this.cleanupAsyncCallStackInterval);
      this.cleanupAsyncCallStackInterval = null;
    }
  }

  heapDump(dumpPath, filename) {
    _logger.logger.debug('heapDumping');

    try {
      const fs = require('fs');

      if (!fs.existsSync(dumpPath)) {
        _logger.logger.error(`heapdump: path doesnt exist + ${dumpPath}`);
      }

      const fd = fs.openSync(dumpPath + filename, 'w');

      if (this.session === null) {
        _logger.logger.error(`heapdump: no inspector session`);

        return;
      }

      this.session.on('HeapProfiler.addHeapSnapshotChunk', m => {
        fs.writeSync(fd, m.params.chunk);
      });
      this.session.post('HeapProfiler.takeHeapSnapshot', null, (err, r) => {
        console.log('HeapProfiler.takeHeapSnapshot done:', err, r);
        fs.closeSync(fd);
      });
    } catch (e) {
      _logger.logger.error('Failed heapdump', e);
    }
  }

  static verifyNoDebuggerConnected() {
    // inspector.url doesn't exist in node.js v8.0.0 - it was added in v8.1.0
    // (although the docs would have you believe it's support in v8.x)
    if (inspector.url !== undefined && inspector.url() !== undefined) {
      throw new _exceptions.RookOtherDebuggerConnected();
    }
  } //NOTE:: if inspect is not specified under electron, inspector api will fail to load
  //NOTE:: its important that this function will happen here and not in the InspectorDebug
  //          since we actually want to fail if inspect is not specified


  static verifyInspectFlagEnabledUnderElectron() {
    let processArguments = process.argv.toString();

    if (!processArguments.includes('--inspect')) {
      throw new _exceptions.RookElectronInspectFlagNotSet();
    }
  }

  static isElectron() {
    return process.argv.toString().includes('electron');
  }

  setBreak(pos) {
    // If we already have a breakpoint on that line, we don't do anything
    if (undefined !== this.positionsToBreakpoints[pos.key]) {
      return;
    }

    let result = {};
    let scriptURL = pos.filename;

    if (url.pathToFileURL !== undefined) {
      scriptURL = url.pathToFileURL(scriptURL);
    }

    const lineNumber = pos.lineno - 1;
    const columnNumber = pos.column ? pos.column - 1 : 0;

    _logger.logger.debug(`setBreakpointByUrl ${scriptURL}:${lineNumber}:${columnNumber}`); // While this function call looks async, in reality the callback will be called before it returns,
    // so we simplify the code


    this.post('Debugger.setBreakpointByUrl', {
      url: scriptURL,
      lineNumber,
      columnNumber
    }, (error, response) => {
      result.error = error;
      result.response = response;
    });

    if (null != result.error) {
      throw new _exceptions.RookInspectorSetBreakpointFailed(result.error);
    }

    this.positionsToBreakpoints[pos.key] = result.response.breakpointId;
    this.breakpointsToPositions[result.response.breakpointId] = pos;
  }

  clearBreak(pos) {
    // If we have an object, hash it
    if (pos.key) {
      pos = pos.key;
    }

    const breakpointId = this.positionsToBreakpoints[pos];

    if (undefined === breakpointId) {
      return;
    }

    delete this.positionsToBreakpoints[pos];
    delete this.breakpointsToPositions[breakpointId];
    let result = {};
    this.post('Debugger.removeBreakpoint', {
      breakpointId: breakpointId
    }, error => {
      result.error = error;
    });

    if (null != result.error) {
      _logger.logger.error("Failed to remove breakpoint", result.error);
    }
  }

  async clearAllBreaks() {
    let positions = Object.keys(this.positionsToBreakpoints);
    positions.map(position => this.clearBreak(position));
    this.positionsToBreakpoints = {};
    this.breakpointsToPositions = {};
  }

  post(message_id, params, cb) {
    const myCb = (...args) => {
      if (cb !== undefined) {
        cb(...args);
      }
    };

    if (this.session === null) {
      if (cb !== undefined) {
        cb(new Error("No debug session"), null);
      }

      return;
    }

    this.session.post(message_id, params, myCb);
  }

  async_post(message_id, params) {
    return new Promise((resolve, reject) => {
      this.post(message_id, params, (err, ...args) => {
        if (err) {
          reject(err);
        } else {
          resolve(args);
        }
      });
    });
  }

  getScript(scriptId) {
    return this.getScriptCallback(scriptId);
  } // TODO - this code can be moved to ScriptNotifier


  resolvePosition(frame) {
    // Check cache before resolving source maps and stuff
    const cacheKey = `${frame.location.scriptId}:${frame.location.lineNumber}:${frame.location.columnNumber}`;
    let position = this.cache.get(cacheKey);

    if (position !== undefined) {
      return position;
    }

    const script = this.getScript(frame.location.scriptId);
    let rawFilename = null;

    if (script !== null) {
      rawFilename = script.filename;
    } else {
      if (frame.url !== undefined) {
        rawFilename = path.basename(frame.url);
      }
    }

    const rawPosition = {
      filename: rawFilename,
      line: frame.location.lineNumber + 1,
      column: frame.location.columnNumber + 1,
      function: frame.functionName
    };

    if (null !== script && null !== script.mapConsumer) {
      let originalPosition = script.getOriginalPosition(rawPosition.line, rawPosition.column);

      if (null != originalPosition) {
        // In case of bad mapping we skip the resolve.
        if (originalPosition.line !== null) {
          position = {
            filename: originalPosition.source,
            line: originalPosition.line,
            column: originalPosition.column,
            function: rawPosition.function
          };

          if (position.function === '' && (typeof originalPosition.name === 'string' || originalPosition.name instanceof String)) {
            position.function = originalPosition.name;
          }
        }
      }
    } // If we have been unable to get original position, just use raw position


    if (null == position) {
      position = rawPosition;
    }

    if (position.function === '') {
      position.function = 'anonymous';
    } // Update cache


    this.cache.set(cacheKey, position);
    return position;
  }

  async close() {
    if (this.session) {
      this.clearCleanupAsyncCallStackInterval();
      await this.clearAllBreaks();
      await this.async_post('Debugger.setBreakpointsActive', {
        active: false
      });
      await this.async_post('Debugger.disable');

      try {
        await this.async_post('Debugger.resume'); // just in case
      } catch (e) {}

      this.session.disconnect();
      this.session = null;
    }
  }

  validate_version(major, minor = 0, patch = 0) {
    /**
     * Validate the current runtime version is above or equal to the given version
     * @param {int} major The major of the checking version
     * @param {int} minor The minor of the checking version
     * @param {int} patch The patch of the checking version
     */
    let [runtimeMajorV, runtimeMinorV, runtimePatchV] = process.version.substr(1).split('.');
    runtimeMajorV = parseInt(runtimeMajorV);
    runtimeMinorV = parseInt(runtimeMinorV);
    runtimePatchV = parseInt(runtimePatchV);
    return runtimeMajorV > major || runtimeMajorV === major && (runtimeMinorV > minor || runtimeMinorV === minor && runtimePatchV >= patch);
  }

}

exports.InspectorDebug = InspectorDebug;
//# sourceMappingURL=InspectorDebug.js.map
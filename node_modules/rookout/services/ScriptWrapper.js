"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logger = require("../logger");

var _sourceMapResolve = require("source-map-resolve");

var _sourceMap = require("source-map");

var _sourceMapUtil = require("./source-map-util");

var _crc = _interopRequireDefault(require("crc/lib/es6/crc32"));

var _utils = require("../utils");

var _exceptions = require("../exceptions");

var _RookError = _interopRequireDefault(require("../processor/RookError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const fs = require('fs');

const path = require('path');

const CryptoJS = require('crypto-js');

const SHA256 = require('crypto-js/sha256');

class ScriptWrapper {
  constructor(id, filename, source) {
    this.id = id;
    this.sourceFiles = [];
    this.filename = filename;
    this.normalizedFilename = (0, _utils.canonizeFileName)(filename);
    this.fileHash = this._generateSourceHash(source);
    this.mapConsumer = null;
    this.loadMap(source);
  }

  loadMap(source) {
    if (!this.filename || !source) {
      return;
    }

    let mapData = null;

    try {
      mapData = (0, _sourceMapResolve.resolveSourceMapSync)(source, this.filename, fs.readFileSync);
    } catch (e) {
      _logger.logger.debug("Unable to find source map", this.filename, e.message);
    }

    if (!mapData || !mapData.map) {
      return;
    }

    const mapObject = mapData.map;
    this.mapConsumer = new _sourceMap.SourceMapConsumer(mapObject);

    for (let sourceFile of mapObject.sources) {
      let source = this.mapConsumer.sourceContentFor(sourceFile, true);
      this.sourceFiles.push({
        normalizedPath: (0, _utils.canonizeFileName)(sourceFile),
        rawPath: sourceFile,
        fileHash: this._generateSourceHash(source),
        linesCrc32s: this._generateLinesCrc32sFromSource(source)
      });
    }
  }

  getMatchInfo(notification) {
    // Exclude NodeJS core libs
    if (!path.isAbsolute(this.filename)) {
      return null;
    }

    if (this.filename.includes('/node_modules/') && !notification.includeExternals) {
      return null;
    }

    let fileSource = null;
    let fileHash = null;
    let linesCrc32s = null;
    let error = null;
    let updatedLineNumber = null;
    let generatedPosition = null;
    let lineno = null;
    let column = null;

    for (let sourceFile of this.sourceFiles) {
      if (this.arePathsConverging(sourceFile.normalizedPath, notification.filename)) {
        // If we are dealing with a transpiled file, we prefer getting the source from disk
        // Otherwise, we have to stick with the source map, even if it's of lower accuracy
        const sourceFilePath = path.join(path.dirname(this.filename), sourceFile.normalizedPath);
        const adjacentSourceFile = path.join(path.dirname(this.filename), path.basename(sourceFile.normalizedPath));

        if (fs.existsSync(sourceFilePath)) {
          fileSource = this.getRawFileContents(sourceFilePath);
          fileHash = this._generateSourceHash(fileSource);
          linesCrc32s = this._generateLinesCrc32sFromSource(fileSource);
        } else if (adjacentSourceFile !== this.filename && fs.existsSync(adjacentSourceFile)) {
          fileSource = this.getRawFileContents(adjacentSourceFile);
          fileHash = this._generateSourceHash(fileSource);
          linesCrc32s = this._generateLinesCrc32sFromSource(fileSource);
        } else {
          fileHash = sourceFile.fileHash;
          linesCrc32s = sourceFile.linesCrc32s;
        }

        try {
          if (fileHash === null || linesCrc32s === null) {
            notification.userWarnings.sendWarning(new _RookError.default(new _exceptions.RookSourceMissing(notification.filename)));
            updatedLineNumber = notification.lineno;
          } else {
            updatedLineNumber = this.getUpdateLineNumber(notification, fileHash, linesCrc32s);
          }

          generatedPosition = this.getGeneratedPosition((0, _sourceMapUtil.normalize)(sourceFile.rawPath), updatedLineNumber, notification.column);
          lineno = generatedPosition.line;
          column = generatedPosition.column;
        } catch (e) {
          // Those exceptions will be handled in LocationFileLine, should be handled here
          lineno = null;
          error = e;
        }

        return {
          script: this,
          lineno: lineno,
          column: column,
          error: error
        };
      }
    }

    if (this.arePathsConverging(this.normalizedFilename, notification.filename)) {
      fileSource = this.getRawFileContents(this.filename);
      fileHash = this._generateSourceHash(fileSource);
      linesCrc32s = this._generateLinesCrc32sFromSource(fileSource);

      try {
        updatedLineNumber = this.getUpdateLineNumber(notification, fileHash, linesCrc32s);
      } catch (e) {
        error = e;
      }

      return {
        script: this,
        lineno: updatedLineNumber,
        column: notification.column,
        error: error
      };
    }

    return null;
  }

  getMatchedFilename(FilenameBase, fileHash) {
    try {
      if (this.sourceFiles === null || this.sourceFiles === undefined) {
        return null;
      }

      for (const sourceFile of this.sourceFiles) {
        if (FilenameBase === path.basename(sourceFile.normalizedPath) && sourceFile.fileHash === fileHash) {
          return sourceFile.normalizedPath;
        }
      }

      if (FilenameBase === path.basename(this.filename) && this.fileHash === fileHash) {
        return this.filename;
      }

      return null;
    } catch (e) {
      return null;
    }
  }

  arePathsConverging(path1, path2) {
    // Find longest match
    let i = path1.length - 1;
    let j = path2.length - 1;

    while (i >= 0 && j >= 0 && path1[i] === path2[j]) {
      --i;
      --j;
    } // Check that at least one of the strings has ended and the other is at a directory boundary


    return i === -1 && path2[j] === path.sep || j === -1 && path1[i] === path.sep || i === -1 && j === -1;
  }

  getUpdateLineNumber(notification, fileHash, linesCrc32s) {
    if (null != notification.lineCrc32 && null != notification.lineUnique) {
      return this.updateLineUsingCrc(notification, fileHash, linesCrc32s);
    }

    if (null != fileHash && null != notification.fileHash) {
      this.testFileHash(notification, fileHash);
      return notification.lineno;
    }

    return notification.lineno;
  }

  updateLineUsingCrc(notification, fileHash, linesCrc32s) {
    // If the line has not changed, we are good - return
    let lineCrc32;

    if (linesCrc32s.length >= notification.lineno) {
      lineCrc32 = linesCrc32s[notification.lineno - 1];
    }

    if (lineCrc32 === notification.lineCrc32) {
      return notification.lineno;
    } // If the line was unique in the original file, let's try to find it in this file


    if (notification.lineUnique === true) {
      // If the line was unique in the original file and is still original here - send a warning and return
      const firstIndex = linesCrc32s.indexOf(notification.lineCrc32);
      const lastIndex = linesCrc32s.lastIndexOf(notification.lineCrc32);

      if (firstIndex !== -1 && firstIndex === lastIndex) {
        const updatedLine = firstIndex + 1;
        notification.userWarnings.sendWarning(new _RookError.default(new _exceptions.RookLineMoved(notification.filename, notification.lineno, updatedLine)));
        return updatedLine;
      }
    } // We failed to get a good match - throw an error


    throw new _exceptions.RookCrcMismatchException(notification.filename, notification.lineCrc32, lineCrc32);
  }

  testFileHash(notification, fileHash) {
    if (fileHash !== notification.fileHash) {
      throw new _exceptions.RookHashMismatchException(notification.filename, notification.fileHash, fileHash);
    }
  }

  getGeneratedPosition(filename, line, column) {
    const position = this.mapConsumer.generatedPositionFor({
      source: filename,
      line: line,
      column: column,
      bias: _sourceMap.SourceMapConsumer.LEAST_UPPER_BOUND
    });

    if (null === position.column) {
      _logger.logger.warn("Got NULL column from source-map!");
    } // generatedPositionFor might return zeroed position instance upon failure and not null


    if (position !== null && position.line !== null) {
      return position;
    } else {
      throw new _exceptions.RookResolveSourceFailed(this.filename);
    }
  }

  getOriginalPosition(line, column) {
    return this.mapConsumer.originalPositionFor({
      line: line,
      column: column
    });
  }

  getRawFileContents(filename) {
    try {
      return fs.readFileSync(filename, 'utf8');
    } catch (e) {
      throw new _exceptions.RookSourceError(this.filename, e);
    }
  }

  _generateLinesCrc32sFromSource(source) {
    if (source === null) {
      return source;
    }

    source = source.replace(/(?:\r\n|\r|\n)/g, "\n");
    const lines = source.split("\n");
    return lines.map(line => (0, _crc.default)(line).toString(16));
  }

  _generateSourceHash(source) {
    if (source === null) {
      return source;
    }

    source = source.replace(/(?:\r\n|\r|\n)/g, "\n");
    return SHA256(source).toString(CryptoJS.enc.Hex);
  }

}

exports.default = ScriptWrapper;
//# sourceMappingURL=ScriptWrapper.js.map
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.systemDataCollector = exports.SystemDataCollector = exports.ProcessUsage = void 0;

const os = require('os');

const process = require('process');

const config = require('../config');

class ProcessUsage {
  constructor(cpu, globalCpu, virtualMemory, startTime, uptime) {
    this.cpu = cpu;
    this.globalCpu = globalCpu;
    this.virtualMemory = virtualMemory;
    this.startTime = startTime;
    this.uptime = uptime;
  }

}

exports.ProcessUsage = ProcessUsage;

class UsageMeasure {
  constructor(usage, total) {
    this.usage = usage;
    this.total = total;
  }

}

function getGlobalUserCpuTicks() {
  let totalGlobalUsage = 0,
      totalTick = 0;
  let cpus = os.cpus();

  for (let i = 0, len = cpus.length; i < len; i++) {
    let cpu = cpus[i];

    for (let type in cpu.times) {
      totalTick += cpu.times[type];
    }

    totalGlobalUsage += cpu.times.user;
  }

  return {
    globalUsage: totalGlobalUsage,
    total: totalTick
  };
}

function getProcessCpuTicks() {
  // returns process cpu time usage in milliseconds
  let processCpuUsage = process.cpuUsage();
  return (processCpuUsage.user + processCpuUsage.system) / 1000;
}

function getCpuTicks() {
  let globalCpuTicks = getGlobalUserCpuTicks();
  let processCpuTicks = getProcessCpuTicks();
  return {
    global: globalCpuTicks.globalUsage,
    process: processCpuTicks,
    total: globalCpuTicks.total
  };
}

function getCpuAverage(startMeasure, endMeasure) {
  let usageDifference = endMeasure.usage - startMeasure.usage;
  let totalDifference = endMeasure.total - startMeasure.total;
  let percentageUserCPU = 100 * usageDifference / totalDifference;
  return percentageUserCPU;
}

function getCpuAverageFromTicks(startTicks, endTicks) {
  let processMeasureStart = new UsageMeasure(startTicks.process, startTicks.total);
  let processMeasureEnd = new UsageMeasure(endTicks.process, endTicks.total);
  let globalMeasureStart = new UsageMeasure(startTicks.global, startTicks.total);
  let globalMeasureEnd = new UsageMeasure(endTicks.global, endTicks.total);
  return {
    process: getCpuAverage(processMeasureStart, processMeasureEnd),
    global: getCpuAverage(globalMeasureStart, globalMeasureEnd)
  };
}

let collectDataRunning = false;
let calculateCpuInterval = null;

class SystemDataCollector {
  constructor() {
    this.lastUsage = null;
    this.previousCpuTicks = null;
    this.collectDataTimeout = null;
  }

  getLastUsage() {
    return systemDataCollector.lastUsage;
  }

  start() {
    if (collectDataRunning) {
      return;
    }

    collectDataRunning = true;
    this.collectDataTimeout = setTimeout(this.collectData, 0).unref();
  }

  close() {
    collectDataRunning = false;
    clearTimeout(this.collectDataTimeout);
    clearInterval(calculateCpuInterval);
  }

  collectData() {
    try {
      this.previousCpuTicks = getCpuTicks();
      const MS_PER_SECOND = 1000;
      let localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
      let nowDate = Date.now();
      let startTime = new Date(nowDate - process.uptime() * MS_PER_SECOND).toLocaleString('en-US', {
        timeZone: localTimeZone
      });
      let uptime = new Date(nowDate - os.uptime() * MS_PER_SECOND).toLocaleString('en-US', {
        timeZone: localTimeZone
      });
      calculateCpuInterval = setInterval(() => {
        try {
          if (!collectDataRunning) return;
          let currentCpuTicks = getCpuTicks();
          let cpuAverage = getCpuAverageFromTicks(this.previousCpuTicks, currentCpuTicks);
          this.previousCpuTicks = currentCpuTicks;
          let virtualMemory = process.memoryUsage().rss;
          systemDataCollector.lastUsage = new ProcessUsage(cpuAverage.process, cpuAverage.global, virtualMemory, startTime, uptime);
        } catch (e) {}
      }, config.MonitorConfiguration.CPU_CHECK_GAP).unref();
    } catch (e) {}
  }

}

exports.SystemDataCollector = SystemDataCollector;
let systemDataCollector = new SystemDataCollector();
exports.systemDataCollector = systemDataCollector;
//# sourceMappingURL=SystemDataCollector.js.map
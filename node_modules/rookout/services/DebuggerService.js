"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebuggerService = void 0;

var _RookError = _interopRequireDefault(require("../processor/RookError"));

var _utils = require("../utils");

var _ScriptWrapper = _interopRequireDefault(require("./ScriptWrapper"));

var _exceptions = require("../exceptions");

var _logger = require("../logger");

var _UserWarnings = _interopRequireDefault(require("../UserWarnings"));

var _IService = require("./IService");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const assert = require('assert');

const path = require('path');

const config = require('../config');

// Note: this is a bit of a heck that is used by V8Debug as well
class Pos {
  constructor(filename, lineno, column) {
    this.filename = filename;
    this.lineno = lineno;
    this.column = column;
    this.key = this.filename + "@" + this.lineno + "@" + this.column;
  }

}

class ScriptNotifier {
  constructor() {
    this.pendingNotifications = {};
    this.scripts = {};
  }

  getAllMatchInfoByNotification(notification) {
    let matchesInfos = [];

    for (let scriptId of Object.keys(this.scripts)) {
      const script = this.scripts[scriptId];
      const matchInfo = script.getMatchInfo(notification);

      if (null !== matchInfo) {
        matchesInfos.push(matchInfo);
      }
    }

    return matchesInfos;
  }

  getScriptObjectById(scriptId) {
    if (this.scripts.hasOwnProperty(scriptId)) {
      return this.scripts[scriptId];
    } else {
      return null;
    }
  }

  registerNotification(aug, filename, fileHash, includeExternals, lineno, lineCrc32, lineUnique, callback, removed) {
    filename = (0, _utils.canonizeFileName)(filename);
    this.pendingNotifications[aug.augId] = {
      userWarnings: new _UserWarnings.default(aug),
      filename: filename,
      includeExternals: includeExternals,
      execute: callback,
      removed: removed,
      fileHash: fileHash,
      lineno: lineno,
      lineCrc32: lineCrc32,
      lineUnique: lineUnique
    };
    const matchInfos = this.getAllMatchInfoByNotification(this.pendingNotifications[aug.augId]);

    if (matchInfos.length > 0) {
      for (let matchInfo of matchInfos) {
        callback(matchInfo);
      }
    } else {
      for (let scriptId of Object.keys(this.scripts)) {
        // TODO - much of this logic is duplicated with "standard" scanning in ScriptWrapper and should be moved there
        const script = this.scripts[scriptId];
        let matchedFilename = script.getMatchedFilename(path.basename(filename), fileHash);

        if (matchedFilename !== null) {
          aug.sendWarning(new _RookError.default(new _exceptions.RookSourceFilePathSuggestion(filename, matchedFilename)));
          break;
        }
      }
    }
  }

  addScript(scriptId, filename, source) {
    if (null == filename || "" === filename || this.scripts.hasOwnProperty(scriptId)) {
      return;
    }

    const scriptWrapper = new _ScriptWrapper.default(scriptId, filename, source);

    for (let augId of Object.keys(this.pendingNotifications)) {
      let notification = this.pendingNotifications[augId];
      const matchInfo = scriptWrapper.getMatchInfo(notification);

      if (null !== matchInfo) {
        notification.execute(matchInfo);
      } else {
        let matchedFilename = scriptWrapper.getMatchedFilename(path.basename(notification.filename), notification.fileHash);

        if (matchedFilename !== null) {
          notification.userWarnings.sendWarning(new _RookError.default(new _exceptions.RookSourceFilePathSuggestion(notification.filename, matchedFilename)));
        }
      }
    }

    this.scripts[scriptId] = scriptWrapper;
  }

  removeAug(augId) {
    let notification = this.pendingNotifications[augId];

    if (undefined !== notification) {
      notification.removed();
      delete this.pendingNotifications[augId];
    }
  }

  clearAugs() {
    let augIds = Object.keys(this.pendingNotifications);

    for (let augId of augIds) {
      this.removeAug(augId);
    }

    this.pendingNotifications = {};
  }

}

class AugsHolder {
  constructor() {
    this.debug = null;
    this.breakpoints = {};
    this.positions = {};
  }

  setDebug(debug) {
    this.debug = debug;
  }

  executeAugs(pos, stack) {
    let augs = this.breakpoints[pos.key];

    if (!augs) {
      _logger.logger.error("Aug not found! %s@%d", pos.filename, pos.lineno);
    } else {
      for (let aug of augs) {
        aug.execute(stack);
      }
    }
  }

  addAug(filename, lineno, column, aug) {
    _logger.logger.info("Setting breakpoint at %s:%s:%s", filename, lineno, column);

    let pos = new Pos((0, _utils.canonizeFileName)(filename), lineno, column);

    if (this.breakpoints.hasOwnProperty(pos.key)) {
      this.breakpoints[pos.key].push(aug);
    } else {
      this.debug.setBreak(pos);
      this.breakpoints[pos.key] = [aug];
    }

    this.positions[aug.augId] = pos;
    aug.setActive();
  }

  removeAugTemporarily(augId, duration) {
    if (!this.positions.hasOwnProperty(augId)) {
      return;
    } // We remove ALL breakpoints from that position


    const pos = this.positions[augId];
    this.debug.clearBreak(pos);
    setTimeout(() => {
      try {
        // Check if we still have augs in that position after the timeout
        const currentAugs = this.breakpoints[pos.key];

        if (undefined === currentAugs || 0 === currentAugs.length) {
          return;
        }

        _logger.logger.info("Re-adding aug %s after %sms", augId, duration);

        this.debug.setBreak(pos);
      } catch (e) {
        try {
          const message = "Exception when adding aug back";

          _logger.logger.exception(message, e);
        } catch (e) {}
      }
    }, duration).uref();
  }

  removeAug(augId) {
    if (!this.positions.hasOwnProperty(augId)) {
      return;
    } // Get current augs in position


    let pos = this.positions[augId];
    let currentAugs = this.breakpoints[pos.key]; // Divide augs into delete and keep

    let augsToKeep = [];
    let augsToDelete = [];

    for (let aug of currentAugs) {
      if (aug.augId === augId) {
        augsToDelete.push(aug);
      } else {
        augsToKeep.push(aug);
      }
    } // Update list


    if (augsToKeep.length > 0) {
      this.breakpoints[pos.key] = augsToKeep;
    } else {
      this.debug.clearBreak(pos);
      delete this.breakpoints[pos.key];
    } // Update status


    for (let aug of augsToDelete) {
      aug.setRemoved();
    } // Remove from position list


    delete this.positions[augId];
  }

  async clearAugs() {
    let augIds = Object.keys(this.positions);

    for (let augId of augIds) {
      this.removeAug(augId);
    }

    this.breakpoints = {};
    this.positions = {};
    await this.debug.clearAllBreaks();
  }

  isEmpty() {
    return Object.keys(this.positions).length === 0;
  }

}

class DebuggerService extends _IService.IService {
  constructor() {
    super();
    this.debug = null;
    this.augsHolder = null;
    this.scriptNotifier = null;
    this.closing = false;
    this.permanently_closed = false;
    this.closeTimeout = null;
  }

  async close(permanent = false) {
    if (permanent) {
      this.permanently_closed = true;
    }

    if (this.closing) {
      return;
    }

    this.closing = true;
    await this.clearAugs();

    if (null !== this.debug) {
      const debug = this.debug;
      this.debug = null;
      await debug.close();
    }

    this.closing = false;
  }

  addAug(matchInfo, aug) {
    if (this.permanently_closed) {
      aug.sendRuleStatus("Error", new _RookError.default(new _exceptions.RookDebuggerPermanentlyClosedException()));
      return;
    }

    this.start(); // Note- this is a hack used to simplify testing, it creates a matchInfo for matchInfo === notification in tests,
    // matchInfo should not hold lineUnique in production

    if (matchInfo.lineUnique !== undefined) {
      matchInfo = this.scriptNotifier.getAllMatchInfoByNotification(matchInfo)[0];
      assert.notEqual(matchInfo, undefined, "Script not found");
    }

    this.augsHolder.addAug(matchInfo.script.filename, matchInfo.lineno, matchInfo.column, aug);
  }

  registerNotification(aug, filename, fileHash, includeExternals, lineno, lineCrc32, lineUnique, callback, removed) {
    if (this.permanently_closed) {
      aug.sendRuleStatus("Error", new _RookError.default(new _exceptions.RookDebuggerPermanentlyClosedException()));
      return;
    }

    this.start();
    this.scriptNotifier.registerNotification(aug, filename, fileHash, includeExternals, lineno, lineCrc32, lineUnique, callback, removed);
  }

  removeAug(augId) {
    if (null !== this.augsHolder) {
      this.augsHolder.removeAug(augId);
    }

    if (null !== this.scriptNotifier) {
      this.scriptNotifier.removeAug(augId);
    }

    this.closeIfNeeded();
  }

  removeAugTemporarily(augId, duration) {
    this.augsHolder.removeAugTemporarily(augId, duration);
  }

  async clearAugs() {
    if (null !== this.augsHolder) {
      await this.augsHolder.clearAugs();
    }

    if (null !== this.scriptNotifier) {
      this.scriptNotifier.clearAugs();
    }

    this.closeIfNeeded();
  }

  start() {
    this.finalizeCloseTimeout();

    if (null === this.debug) {
      this.scriptNotifier = new ScriptNotifier();
      this.augsHolder = new AugsHolder();
      this.debug = this.getDebugger();
      this.augsHolder.setDebug(this.debug);

      if (config.HeapSnapshotConfiguration.HEAP_PATH !== null) {
        _logger.logger.debug('registering signal ' + config.HeapSnapshotConfiguration.SIGNAL);

        process.on(config.HeapSnapshotConfiguration.SIGNAL, () => {
          let date = new Date().toISOString();

          _logger.logger.info('Rook is saving a heap snapshot to: ' + config.HeapSnapshotConfiguration.HEAP_PATH);

          this.debug.heapDump(config.HeapSnapshotConfiguration.HEAP_PATH, '/rookout_' + date + '.heapsnapshot');
        });
      }
    }
  }

  closeIfNeeded() {
    if (null !== this.closeTimeout || this.augsHolder === null || !this.augsHolder.isEmpty()) {
      return;
    }

    this.closeTimeout = setTimeout(async () => {
      try {
        await this.close();
        this.finalizeCloseTimeout();
      } catch (error) {}
    }, config.DebuggerService.WAIT_SECONDS_TO_CLOSE_DEBUGGER_AFTER_NO_AUGS * 1000).unref();
  }

  getDebugger() {
    const versions = process.version.split('.');
    const major = parseInt(versions[0].substr(1));

    if (major < 8) {
      throw new _exceptions.RookUnsupportedNodeVersion(process.version);
    }

    const InspectorDebug = require('./InspectorDebug');

    return new InspectorDebug.InspectorDebug(this.augsHolder.executeAugs.bind(this.augsHolder), this.scriptNotifier.addScript.bind(this.scriptNotifier), this.scriptNotifier.getScriptObjectById.bind(this.scriptNotifier), this);
  }

  finalizeCloseTimeout() {
    if (this.closeTimeout !== null) {
      clearTimeout(this.closeTimeout);
      this.closeTimeout = null;
    }
  }

}

exports.DebuggerService = DebuggerService;
//# sourceMappingURL=DebuggerService.js.map
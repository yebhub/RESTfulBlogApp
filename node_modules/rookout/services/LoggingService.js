"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LoggingService = void 0;

var _ContainerNamespace = _interopRequireDefault(require("../processor/namespaces/ContainerNamespace"));

var _LogRecordNamespace = _interopRequireDefault(require("../processor/namespaces/LogRecordNamespace"));

var _logger = require("../logger");

var _IService = require("./IService");

var _LogRecord = require("./LogRecord");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const config = require("../config");

const rookoutTransportName = 'rookoutTransport';
const transportNameInUpperCase = rookoutTransportName.charAt(0).toUpperCase() + rookoutTransportName.slice(1);

class LoggingService extends _IService.IService {
  constructor() {
    super();
    this.augs = {};
  }

  start() {
    // if winston isn't installed this will throw an exception which will be caught by TriggerServices which will skip the service.
    const winston = (0, _utils.conditionalRequire)('winston');
    let Transport;

    if (winston) {
      Transport = winston.Transport || (0, _utils.conditionalRequire)('winston-transport');
    }

    if (winston && Transport) {
      const isWinston3 = winston.version.startsWith("3.");
      const isWinston2 = winston.version.startsWith("2.");

      if (isWinston3) {
        // override winston.createLogger(). the logger creator for winston 3.*
        const originalCreateLogger = winston.createLogger;

        if (originalCreateLogger !== undefined) {
          if (originalCreateLogger.toString().split('\n')[0].includes("(opts = {})")) {
            winston.createLogger = (opts = {}) => {
              opts.transports = this.addRookoutWinstonTransportToTransports(opts.transports, isWinston3);
              return originalCreateLogger(opts);
            };

            _logger.logger.info("Hooked winston.createLogger");
          } else {
            _logger.logger.error("did not override winston.createLogger() because of unexpected args", {
              func: winston.createLogger.toString()
            });
          }
        } else {
          _logger.logger.info("Skipped winston.createdLogger (missing)");
        }
      }

      if (isWinston2) {
        // override the configure prototype which is called from the constructor, constructor is overrun by inheritence. this is winston 2.* specific
        const originalLoggerConfigure = winston.Logger.prototype.configure;

        if (originalLoggerConfigure !== undefined) {
          if (originalLoggerConfigure.toString().split('\n')[0].includes("(options)")) {
            const callAddRookoutTransportToTransports = transports => this.addRookoutWinstonTransportToTransports(transports, isWinston3);

            winston.Logger.prototype.configure = function (options) {
              options.transports = callAddRookoutTransportToTransports(options.transports);
              return originalLoggerConfigure.apply(this, [options]);
            };

            _logger.logger.info("Hooked winston.Logger.prototype.configure");
          } else {
            _logger.logger.error("did not override winston.Logger.prototype.configure() constructor because of unexpected args", {
              func: winston.Logger.prototype.configure.toString()
            });
          }
        } else {
          _logger.logger.info("Skipped winston.Logger.prototype.configure (missing)");
        }
      }

      if (isWinston3) {
        // override winston.loggers.add() for winston 3. winston 2.* doesn't need monkey patching for loggers.add()
        // because it uses the Logger constructor we have already patched.
        const originalAddLogger = winston.loggers.add;

        if (originalAddLogger.length === 2) {
          const callAddRookoutTransportToTransports = options => this.addRookoutWinstonTransportToTransports(options.transports, isWinston3);

          winston.loggers.add = function (id, options = {}) {
            options.transports = callAddRookoutTransportToTransports(options);
            return originalAddLogger.apply(this, [id, options]);
          };

          _logger.logger.info("Hooked winston.loggers.add()");
        } else {
          _logger.logger.error("did not override winston.loggers.add() because of unexpected args", {
            func: winston.loggers.add.toString()
          });
        }
      } // add Rookout logging transport to existing loggers in the default container


      const defaultContainer = winston.loggers;

      if (defaultContainer !== undefined) {
        const loggers = defaultContainer.loggers;

        if (loggers) {
          if (isWinston3) {
            // winston 3.*
            const RookoutWinston3Transport = this.getRookoutWinston3TransportClass();

            if (RookoutWinston3Transport) {
              loggers.forEach(loggerInstance => {
                loggerInstance.add(new RookoutWinston3Transport({}));
              });

              _logger.logger.info("added Rookout transport to winston 3.* default container loggers");
            }
          } else if (isWinston2) {
            // winston 2.*
            const RookoutWinston2Transport = this.getRookoutWinston2TransportClass();
            winston.transports[transportNameInUpperCase] = RookoutWinston2Transport;

            if (RookoutWinston2Transport) {
              for (const [key, loggerInstance] of Object.entries(loggers)) {
                loggerInstance.add(RookoutWinston2Transport, {});
              }

              _logger.logger.info("added Rookout transport to winston 2.* default container loggers");
            }
          }
        }
      } // add Rookout logging transport to winston default logger. `winston.info("log message")`


      const defaultLogger = winston.default;

      if (defaultLogger !== undefined) {
        if (isWinston3) {
          const RookoutWinston3Transport = this.getRookoutWinston3TransportClass();

          if (RookoutWinston3Transport) {
            winston.add(new RookoutWinston3Transport({}));

            _logger.logger.info("added Rookout transport to winston 3.* default logger");
          }
        } else if (isWinston2) {
          const RookoutWinston2Transport = this.getRookoutWinston2TransportClass(); // in winston 2.* it's required to add our transport to the list of valid transports

          winston.transports[transportNameInUpperCase] = RookoutWinston2Transport;

          if (RookoutWinston2Transport) {
            winston.add(RookoutWinston2Transport, {});

            _logger.logger.info("added Rookout transport to winston 2.* default logger");
          }
        }
      } // todo: loggers created by winston.createLogger() before rookout init and weren't saved into a container. (winston 3.*)
      // example:
      //   const logger = winston.createLogger();
      //   rookout.start();
      //   logger.info('hello world');
      // todo: loggers created by new winston.Logger() before rookout init and weren't saved into a container. (winston 2.*)
      // example:
      //   const logger = new winston.Logger();
      //   rookout.start();
      //   logger.info('hello world');
      // todo: loggers created inside manual containers before rookout init.
      // example:
      //   const container = new winston.Container();
      //   container.add('logger-id', opts);
      //   rookout.start();
      //   const logger = conainer.get('logger-id');
      //   logger.info('hello world');


      this.hookConsoleLogFunctionsIfDefined();
    }
  }

  addRookoutWinstonTransportToTransports(existingTransports, isWinston3) {
    const RookoutWinstonTransport = isWinston3 ? this.getRookoutWinston3TransportClass() : this.getRookoutWinston2TransportClass();

    if (!isWinston3) {
      // in winston 2.* it's required to add our transport to the list of valid transports
      const winston = (0, _utils.conditionalRequire)('winston');
      winston.transports[transportNameInUpperCase] = RookoutWinstonTransport;
    }

    if (RookoutWinstonTransport) {
      const newTransport = new RookoutWinstonTransport({});

      if (Array.isArray(existingTransports)) {
        if (existingTransports.some(transport => transport instanceof RookoutWinstonTransport)) {
          return existingTransports;
        }

        return [newTransport, ...existingTransports];
      } else if (existingTransports) {
        if (existingTransports instanceof RookoutWinstonTransport) {
          return existingTransports;
        }

        return [newTransport, existingTransports];
      } else {
        return [newTransport];
      }
    }

    return existingTransports;
  }

  getRookoutWinston3TransportClass() {
    const winston = (0, _utils.conditionalRequire)('winston');
    const Transport = (0, _utils.conditionalRequire)('winston-transport');

    if (winston && Transport) {
      const onNewLog = info => this.onNewLog(this.augs, info, _LogRecord.LogModules.WINSTON3);

      if (Transport) {
        return class RookoutWinston3Transport extends Transport {
          constructor(opts) {
            opts.level = 'debug';
            super(opts);
          }

          log(info, callback) {
            setImmediate(() => {
              this.emit('logged', info);
            });
            info.created = Date.now() / 1000;
            onNewLog(info);
            callback();
          }

        };
      }
    }

    return null;
  }

  getRookoutWinston2TransportClass() {
    const winston = (0, _utils.conditionalRequire)('winston');

    if (winston) {
      const Transport = winston.Transport;

      if (Transport) {
        const onNewLog = info => this.onNewLog(this.augs, info, _LogRecord.LogModules.WINSTON2);

        if (Transport) {
          return class RookoutWinston2Transport extends Transport {
            constructor(opts) {
              opts.name = rookoutTransportName;
              opts.level = 'debug';
              super(opts);
            }

            log(level, message, meta, callback) {
              setImmediate(() => {
                this.emit('logged', message);
              });
              const info = {
                message,
                level,
                created: Date.now() / 1000
              };
              onNewLog(info);
              callback();
            }

          };
        }
      }
    }

    return null;
  }

  hookConsoleLogFunctionsIfDefined() {
    if (config.LogHandlerService.CONSOLE_FUNCTIONS_HOOK_ENABLED !== false && typeof console !== "undefined") {
      this.hookConsoleLogFunctions();

      _logger.logger.debug('Successfully hooked console.log');
    }
  }

  hookConsoleLogFunctions() {
    this.hookConsoleLogFunction();
    this.hookConsoleDebugFunction();
    this.hookConsoleInfoFunction();
    this.hookConsoleWarnFunction();
    this.hookConsoleErrorFunction();
    this.hookConsoleTraceFunction();
  }

  hookConsoleLogFunction() {
    const originalConsoleLog = console.log;

    console.log = (...args) => {
      this.onNewLog(this.augs, {
        message: args,
        level: "LOG",
        created: Date.now() / 1000
      }, _LogRecord.LogModules.CONSOLE);
      originalConsoleLog(...args);
    };
  }

  hookConsoleDebugFunction() {
    const originalConsoleDebug = console.debug;

    console.debug = (...args) => {
      this.onNewLog(this.augs, {
        message: args,
        level: "DEBUG",
        created: Date.now() / 1000
      }, _LogRecord.LogModules.CONSOLE);
      originalConsoleDebug(...args);
    };
  }

  hookConsoleInfoFunction() {
    const originalConsoleInfo = console.info;

    console.info = (...args) => {
      this.onNewLog(this.augs, {
        message: args,
        level: "INFO",
        created: Date.now() / 1000
      }, _LogRecord.LogModules.CONSOLE);
      originalConsoleInfo(...args);
    };
  }

  hookConsoleWarnFunction() {
    const originalConsoleWarn = console.warn;

    console.warn = (...args) => {
      this.onNewLog(this.augs, {
        message: args,
        level: "WARN",
        created: Date.now() / 1000
      }, _LogRecord.LogModules.CONSOLE);
      originalConsoleWarn(...args);
    };
  }

  hookConsoleErrorFunction() {
    const originalConsoleError = console.error;

    console.error = (...args) => {
      this.onNewLog(this.augs, {
        message: args,
        level: "ERROR",
        created: Date.now() / 1000
      }, _LogRecord.LogModules.CONSOLE);
      originalConsoleError(...args);
    };
  }

  hookConsoleTraceFunction() {
    const originalConsoleTrace = console.trace;

    console.trace = (...args) => {
      this.onNewLog(this.augs, {
        message: args,
        level: "TRACE",
        created: Date.now() / 1000
      }, _LogRecord.LogModules.CONSOLE);
      originalConsoleTrace(...args);
    };
  }

  addLoggingAug(aug) {
    _logger.logger.debug('Adding Logging Aug, ' + aug.augId);

    this.augs[aug.augId] = aug;
    aug.setActive();
  }

  removeAug(augId) {
    _logger.logger.debug('Removing Logging Aug, ' + augId);

    delete this.augs[augId];
  }

  clearAugs() {
    this.augs = {};
  }

  executeAugs(record) {
    const extracted = new _ContainerNamespace.default({
      'log_record': new _LogRecordNamespace.default(record)
    });

    for (const aug of Object.values(this.augs)) {
      aug.execute(null, extracted);
    }
  }

  onNewLog(augs, record, module) {
    if (Object.keys(augs).length > 0) {
      this.executeAugs(new _LogRecord.LogRecord(record, module));
    }
  }

}

exports.LoggingService = LoggingService;
//# sourceMappingURL=LoggingService.js.map